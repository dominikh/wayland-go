// Code generated by wayland-scanner; DO NOT EDIT.

// Package wayland contains generated definitions of the wayland Wayland protocol.
package wayland

import (
	"honnef.co/go/wayland/wlproto"
	"honnef.co/go/wayland/wlserver"
	"honnef.co/go/wayland/wlshared"
	"reflect"
)

var _ wlshared.Fixed

var interfaceNames = map[string]string{
	"wl_display":             "Display",
	"wl_registry":            "Registry",
	"wl_callback":            "Callback",
	"wl_compositor":          "Compositor",
	"wl_shm_pool":            "ShmPool",
	"wl_shm":                 "Shm",
	"wl_buffer":              "Buffer",
	"wl_data_offer":          "DataOffer",
	"wl_data_source":         "DataSource",
	"wl_data_device":         "DataDevice",
	"wl_data_device_manager": "DataDeviceManager",
	"wl_shell":               "Shell",
	"wl_shell_surface":       "ShellSurface",
	"wl_surface":             "Surface",
	"wl_seat":                "Seat",
	"wl_pointer":             "Pointer",
	"wl_keyboard":            "Keyboard",
	"wl_touch":               "Touch",
	"wl_output":              "Output",
	"wl_region":              "Region",
	"wl_subcompositor":       "Subcompositor",
	"wl_subsurface":          "Subsurface",
}

var Interfaces = map[string]*wlproto.Interface{
	"wl_display":             DisplayInterface,
	"wl_registry":            RegistryInterface,
	"wl_callback":            CallbackInterface,
	"wl_compositor":          CompositorInterface,
	"wl_shm_pool":            ShmPoolInterface,
	"wl_shm":                 ShmInterface,
	"wl_buffer":              BufferInterface,
	"wl_data_offer":          DataOfferInterface,
	"wl_data_source":         DataSourceInterface,
	"wl_data_device":         DataDeviceInterface,
	"wl_data_device_manager": DataDeviceManagerInterface,
	"wl_shell":               ShellInterface,
	"wl_shell_surface":       ShellSurfaceInterface,
	"wl_surface":             SurfaceInterface,
	"wl_seat":                SeatInterface,
	"wl_pointer":             PointerInterface,
	"wl_keyboard":            KeyboardInterface,
	"wl_touch":               TouchInterface,
	"wl_output":              OutputInterface,
	"wl_region":              RegionInterface,
	"wl_subcompositor":       SubcompositorInterface,
	"wl_subsurface":          SubsurfaceInterface,
}

var Requests = map[string]*wlproto.Request{
	"wl_display_sync":                           &DisplayInterface.Requests[0],
	"wl_display_get_registry":                   &DisplayInterface.Requests[1],
	"wl_registry_bind":                          &RegistryInterface.Requests[0],
	"wl_compositor_create_surface":              &CompositorInterface.Requests[0],
	"wl_compositor_create_region":               &CompositorInterface.Requests[1],
	"wl_shm_pool_create_buffer":                 &ShmPoolInterface.Requests[0],
	"wl_shm_pool_destroy":                       &ShmPoolInterface.Requests[1],
	"wl_shm_pool_resize":                        &ShmPoolInterface.Requests[2],
	"wl_shm_create_pool":                        &ShmInterface.Requests[0],
	"wl_buffer_destroy":                         &BufferInterface.Requests[0],
	"wl_data_offer_accept":                      &DataOfferInterface.Requests[0],
	"wl_data_offer_receive":                     &DataOfferInterface.Requests[1],
	"wl_data_offer_destroy":                     &DataOfferInterface.Requests[2],
	"wl_data_offer_finish":                      &DataOfferInterface.Requests[3],
	"wl_data_offer_set_actions":                 &DataOfferInterface.Requests[4],
	"wl_data_source_offer":                      &DataSourceInterface.Requests[0],
	"wl_data_source_destroy":                    &DataSourceInterface.Requests[1],
	"wl_data_source_set_actions":                &DataSourceInterface.Requests[2],
	"wl_data_device_start_drag":                 &DataDeviceInterface.Requests[0],
	"wl_data_device_set_selection":              &DataDeviceInterface.Requests[1],
	"wl_data_device_release":                    &DataDeviceInterface.Requests[2],
	"wl_data_device_manager_create_data_source": &DataDeviceManagerInterface.Requests[0],
	"wl_data_device_manager_get_data_device":    &DataDeviceManagerInterface.Requests[1],
	"wl_shell_get_shell_surface":                &ShellInterface.Requests[0],
	"wl_shell_surface_pong":                     &ShellSurfaceInterface.Requests[0],
	"wl_shell_surface_move":                     &ShellSurfaceInterface.Requests[1],
	"wl_shell_surface_resize":                   &ShellSurfaceInterface.Requests[2],
	"wl_shell_surface_set_toplevel":             &ShellSurfaceInterface.Requests[3],
	"wl_shell_surface_set_transient":            &ShellSurfaceInterface.Requests[4],
	"wl_shell_surface_set_fullscreen":           &ShellSurfaceInterface.Requests[5],
	"wl_shell_surface_set_popup":                &ShellSurfaceInterface.Requests[6],
	"wl_shell_surface_set_maximized":            &ShellSurfaceInterface.Requests[7],
	"wl_shell_surface_set_title":                &ShellSurfaceInterface.Requests[8],
	"wl_shell_surface_set_class":                &ShellSurfaceInterface.Requests[9],
	"wl_surface_destroy":                        &SurfaceInterface.Requests[0],
	"wl_surface_attach":                         &SurfaceInterface.Requests[1],
	"wl_surface_damage":                         &SurfaceInterface.Requests[2],
	"wl_surface_frame":                          &SurfaceInterface.Requests[3],
	"wl_surface_set_opaque_region":              &SurfaceInterface.Requests[4],
	"wl_surface_set_input_region":               &SurfaceInterface.Requests[5],
	"wl_surface_commit":                         &SurfaceInterface.Requests[6],
	"wl_surface_set_buffer_transform":           &SurfaceInterface.Requests[7],
	"wl_surface_set_buffer_scale":               &SurfaceInterface.Requests[8],
	"wl_surface_damage_buffer":                  &SurfaceInterface.Requests[9],
	"wl_surface_offset":                         &SurfaceInterface.Requests[10],
	"wl_seat_get_pointer":                       &SeatInterface.Requests[0],
	"wl_seat_get_keyboard":                      &SeatInterface.Requests[1],
	"wl_seat_get_touch":                         &SeatInterface.Requests[2],
	"wl_seat_release":                           &SeatInterface.Requests[3],
	"wl_pointer_set_cursor":                     &PointerInterface.Requests[0],
	"wl_pointer_release":                        &PointerInterface.Requests[1],
	"wl_keyboard_release":                       &KeyboardInterface.Requests[0],
	"wl_touch_release":                          &TouchInterface.Requests[0],
	"wl_output_release":                         &OutputInterface.Requests[0],
	"wl_region_destroy":                         &RegionInterface.Requests[0],
	"wl_region_add":                             &RegionInterface.Requests[1],
	"wl_region_subtract":                        &RegionInterface.Requests[2],
	"wl_subcompositor_destroy":                  &SubcompositorInterface.Requests[0],
	"wl_subcompositor_get_subsurface":           &SubcompositorInterface.Requests[1],
	"wl_subsurface_destroy":                     &SubsurfaceInterface.Requests[0],
	"wl_subsurface_set_position":                &SubsurfaceInterface.Requests[1],
	"wl_subsurface_place_above":                 &SubsurfaceInterface.Requests[2],
	"wl_subsurface_place_below":                 &SubsurfaceInterface.Requests[3],
	"wl_subsurface_set_sync":                    &SubsurfaceInterface.Requests[4],
	"wl_subsurface_set_desync":                  &SubsurfaceInterface.Requests[5],
}

var Events = map[string]*wlproto.Event{
	"wl_display_error":                  &DisplayInterface.Events[0],
	"wl_display_delete_id":              &DisplayInterface.Events[1],
	"wl_registry_global":                &RegistryInterface.Events[0],
	"wl_registry_global_remove":         &RegistryInterface.Events[1],
	"wl_callback_done":                  &CallbackInterface.Events[0],
	"wl_shm_format":                     &ShmInterface.Events[0],
	"wl_buffer_release":                 &BufferInterface.Events[0],
	"wl_data_offer_offer":               &DataOfferInterface.Events[0],
	"wl_data_offer_source_actions":      &DataOfferInterface.Events[1],
	"wl_data_offer_action":              &DataOfferInterface.Events[2],
	"wl_data_source_target":             &DataSourceInterface.Events[0],
	"wl_data_source_send":               &DataSourceInterface.Events[1],
	"wl_data_source_cancelled":          &DataSourceInterface.Events[2],
	"wl_data_source_dnd_drop_performed": &DataSourceInterface.Events[3],
	"wl_data_source_dnd_finished":       &DataSourceInterface.Events[4],
	"wl_data_source_action":             &DataSourceInterface.Events[5],
	"wl_data_device_data_offer":         &DataDeviceInterface.Events[0],
	"wl_data_device_enter":              &DataDeviceInterface.Events[1],
	"wl_data_device_leave":              &DataDeviceInterface.Events[2],
	"wl_data_device_motion":             &DataDeviceInterface.Events[3],
	"wl_data_device_drop":               &DataDeviceInterface.Events[4],
	"wl_data_device_selection":          &DataDeviceInterface.Events[5],
	"wl_shell_surface_ping":             &ShellSurfaceInterface.Events[0],
	"wl_shell_surface_configure":        &ShellSurfaceInterface.Events[1],
	"wl_shell_surface_popup_done":       &ShellSurfaceInterface.Events[2],
	"wl_surface_enter":                  &SurfaceInterface.Events[0],
	"wl_surface_leave":                  &SurfaceInterface.Events[1],
	"wl_seat_capabilities":              &SeatInterface.Events[0],
	"wl_seat_name":                      &SeatInterface.Events[1],
	"wl_pointer_enter":                  &PointerInterface.Events[0],
	"wl_pointer_leave":                  &PointerInterface.Events[1],
	"wl_pointer_motion":                 &PointerInterface.Events[2],
	"wl_pointer_button":                 &PointerInterface.Events[3],
	"wl_pointer_axis":                   &PointerInterface.Events[4],
	"wl_pointer_frame":                  &PointerInterface.Events[5],
	"wl_pointer_axis_source":            &PointerInterface.Events[6],
	"wl_pointer_axis_stop":              &PointerInterface.Events[7],
	"wl_pointer_axis_discrete":          &PointerInterface.Events[8],
	"wl_keyboard_keymap":                &KeyboardInterface.Events[0],
	"wl_keyboard_enter":                 &KeyboardInterface.Events[1],
	"wl_keyboard_leave":                 &KeyboardInterface.Events[2],
	"wl_keyboard_key":                   &KeyboardInterface.Events[3],
	"wl_keyboard_modifiers":             &KeyboardInterface.Events[4],
	"wl_keyboard_repeat_info":           &KeyboardInterface.Events[5],
	"wl_touch_down":                     &TouchInterface.Events[0],
	"wl_touch_up":                       &TouchInterface.Events[1],
	"wl_touch_motion":                   &TouchInterface.Events[2],
	"wl_touch_frame":                    &TouchInterface.Events[3],
	"wl_touch_cancel":                   &TouchInterface.Events[4],
	"wl_touch_shape":                    &TouchInterface.Events[5],
	"wl_touch_orientation":              &TouchInterface.Events[6],
	"wl_output_geometry":                &OutputInterface.Events[0],
	"wl_output_mode":                    &OutputInterface.Events[1],
	"wl_output_done":                    &OutputInterface.Events[2],
	"wl_output_scale":                   &OutputInterface.Events[3],
	"wl_output_name":                    &OutputInterface.Events[4],
	"wl_output_description":             &OutputInterface.Events[5],
}

// These errors are global and can be emitted in response to any
// server request.
type DisplayError uint32

const (
	// server couldn't find object
	DisplayErrorInvalidObject DisplayError = 0
	// method doesn't exist on the specified interface or malformed request
	DisplayErrorInvalidMethod DisplayError = 1
	// server is out of memory
	DisplayErrorNoMemory DisplayError = 2
	// implementation error in compositor
	DisplayErrorImplementation DisplayError = 3
)

var DisplayInterface = &wlproto.Interface{
	Name:    "wl_display",
	Version: 1,
	Type:    reflect.TypeOf(Display{}),
	Requests: []wlproto.Request{
		{
			Name:   "sync",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DisplayImplementation.Sync),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Callback{})},
			},
		},
		{
			Name:   "get_registry",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DisplayImplementation.GetRegistry),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Registry{})},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "error",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:  "delete_id",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
			},
		},
	},
}

// The core global object.  This is a special singleton object.  It
// is used for internal Wayland protocol features.
type Display struct{ wlserver.Resource }

func (Display) Interface() *wlproto.Interface { return DisplayInterface }

type DisplayImplementation interface {
	Sync(obj Display, callback Callback) CallbackImplementation
	GetRegistry(obj Display, registry Registry) RegistryImplementation
}

func AddDisplayGlobal(dsp *wlserver.Display, version int, bind func(res Display) DisplayImplementation) {
	dsp.AddGlobal(DisplayInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Display)) })
}

// The error event is sent out when a fatal (non-recoverable)
// error has occurred.  The object_id argument is the object
// where the error occurred, most often in response to a request
// to that object.  The code identifies the error and is defined
// by the object interface.  As such, each interface defines its
// own set of error codes.  The message is a brief description
// of the error, for (debugging) convenience.
func (obj Display) Error(objectId wlserver.Object, code uint32, message string) {
	obj.Conn().SendEvent(obj, 0, objectId, code, message)
}

// This event is used internally by the object ID management
// logic. When a client deletes an object that it had created,
// the server will send this event to acknowledge that it has
// seen the delete request. When the client receives this event,
// it will know that it can safely reuse the object ID.
func (obj Display) DeleteID(id uint32) {
	obj.Conn().SendEvent(obj, 1, id)
}

var RegistryInterface = &wlproto.Interface{
	Name:    "wl_registry",
	Version: 1,
	Type:    reflect.TypeOf(Registry{}),
	Requests: []wlproto.Request{
		{
			Name:   "bind",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(RegistryImplementation.Bind),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeString}, {Type: wlproto.ArgTypeUint}, {Type: wlproto.ArgTypeNewID},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "global",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeString},
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:  "global_remove",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
			},
		},
	},
}

// The singleton global registry object.  The server has a number of
// global objects that are available to all clients.  These objects
// typically represent an actual object in the server (for example,
// an input device) or they are singleton objects that provide
// extension functionality.
//
// When a client creates a registry object, the registry object
// will emit a global event for each global currently in the
// registry.  Globals come and go as a result of device or
// monitor hotplugs, reconfiguration or other events, and the
// registry will send out global and global_remove events to
// keep the client up to date with the changes.  To mark the end
// of the initial burst of events, the client can use the
// wl_display.sync request immediately after calling
// wl_display.get_registry.
//
// A client can bind to a global object by using the bind
// request.  This creates a client-side handle that lets the object
// emit events to the client and lets the client invoke requests on
// the object.
type Registry struct{ wlserver.Resource }

func (Registry) Interface() *wlproto.Interface { return RegistryInterface }

type RegistryImplementation interface {
	Bind(obj Registry, name uint32, id wlserver.Object) wlserver.ResourceImplementation
}

func AddRegistryGlobal(dsp *wlserver.Display, version int, bind func(res Registry) RegistryImplementation) {
	dsp.AddGlobal(RegistryInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Registry)) })
}

// Notify the client of global objects.
//
// The event notifies the client that a global object with
// the given name is now available, and it implements the
// given version of the given interface.
func (obj Registry) Global(name uint32, interface_ string, version uint32) {
	obj.Conn().SendEvent(obj, 0, name, interface_, version)
}

// Notify the client of removed global objects.
//
// This event notifies the client that the global identified
// by name is no longer available.  If the client bound to
// the global using the bind request, the client should now
// destroy that object.
//
// The object remains valid and requests to the object will be
// ignored until the client destroys it, to avoid races between
// the global going away and a client sending a request to it.
func (obj Registry) GlobalRemove(name uint32) {
	obj.Conn().SendEvent(obj, 1, name)
}

var CallbackInterface = &wlproto.Interface{
	Name:     "wl_callback",
	Version:  1,
	Type:     reflect.TypeOf(Callback{}),
	Requests: []wlproto.Request{},
	Events: []wlproto.Event{
		{
			Name:  "done",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
			},
		},
	},
}

// Clients can handle the 'done' event to get notified when
// the related request is done.
type Callback struct{ wlserver.Resource }

func (Callback) Interface() *wlproto.Interface { return CallbackInterface }

type CallbackImplementation interface {
}

func AddCallbackGlobal(dsp *wlserver.Display, version int, bind func(res Callback) CallbackImplementation) {
	dsp.AddGlobal(CallbackInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Callback)) })
}

// Notify the client when the related request is done.
func (obj Callback) Done(callbackData uint32) {
	obj.Conn().SendEvent(obj, 0, callbackData)
}

var CompositorInterface = &wlproto.Interface{
	Name:    "wl_compositor",
	Version: 5,
	Type:    reflect.TypeOf(Compositor{}),
	Requests: []wlproto.Request{
		{
			Name:   "create_surface",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(CompositorImplementation.CreateSurface),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Surface{})},
			},
		},
		{
			Name:   "create_region",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(CompositorImplementation.CreateRegion),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Region{})},
			},
		},
	},
	Events: []wlproto.Event{},
}

// A compositor.  This object is a singleton global.  The
// compositor is in charge of combining the contents of multiple
// surfaces into one displayable output.
type Compositor struct{ wlserver.Resource }

func (Compositor) Interface() *wlproto.Interface { return CompositorInterface }

type CompositorImplementation interface {
	CreateSurface(obj Compositor, id Surface) SurfaceImplementation
	CreateRegion(obj Compositor, id Region) RegionImplementation
}

func AddCompositorGlobal(dsp *wlserver.Display, version int, bind func(res Compositor) CompositorImplementation) {
	dsp.AddGlobal(CompositorInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Compositor)) })
}

var ShmPoolInterface = &wlproto.Interface{
	Name:    "wl_shm_pool",
	Version: 1,
	Type:    reflect.TypeOf(ShmPool{}),
	Requests: []wlproto.Request{
		{
			Name:   "create_buffer",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShmPoolImplementation.CreateBuffer),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Buffer{})},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShmFormat(0))},
			},
		},
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(ShmPoolImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "resize",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShmPoolImplementation.Resize),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
			},
		},
	},
	Events: []wlproto.Event{},
}

// The wl_shm_pool object encapsulates a piece of memory shared
// between the compositor and client.  Through the wl_shm_pool
// object, the client can allocate shared memory wl_buffer objects.
// All objects created through the same pool share the same
// underlying mapped memory. Reusing the mapped memory avoids the
// setup/teardown overhead and is useful when interactively resizing
// a surface or for many small buffers.
type ShmPool struct{ wlserver.Resource }

func (ShmPool) Interface() *wlproto.Interface { return ShmPoolInterface }

type ShmPoolImplementation interface {
	CreateBuffer(obj ShmPool, id Buffer, offset int32, width int32, height int32, stride int32, format ShmFormat) BufferImplementation
	Destroy(obj ShmPool)
	Resize(obj ShmPool, size int32)
}

func AddShmPoolGlobal(dsp *wlserver.Display, version int, bind func(res ShmPool) ShmPoolImplementation) {
	dsp.AddGlobal(ShmPoolInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(ShmPool)) })
}

// These errors can be emitted in response to wl_shm requests.
type ShmError uint32

const (
	// buffer format is not known
	ShmErrorInvalidFormat ShmError = 0
	// invalid size or stride during pool or buffer creation
	ShmErrorInvalidStride ShmError = 1
	// mmapping the file descriptor failed
	ShmErrorInvalidFd ShmError = 2
)

// This describes the memory layout of an individual pixel.
//
// All renderers should support argb8888 and xrgb8888 but any other
// formats are optional and may not be supported by the particular
// renderer in use.
//
// The drm format codes match the macros defined in drm_fourcc.h, except
// argb8888 and xrgb8888. The formats actually supported by the compositor
// will be reported by the format event.
//
// For all wl_shm formats and unless specified in another protocol
// extension, pre-multiplied alpha is used for pixel values.
type ShmFormat uint32

const (
	// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	ShmFormatArgb8888 ShmFormat = 0
	// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	ShmFormatXrgb8888 ShmFormat = 1
	// 8-bit color index format, [7:0] C
	ShmFormatC8 ShmFormat = 0x20203843
	// 8-bit RGB format, [7:0] R:G:B 3:3:2
	ShmFormatRgb332 ShmFormat = 0x38424752
	// 8-bit BGR format, [7:0] B:G:R 2:3:3
	ShmFormatBgr233 ShmFormat = 0x38524742
	// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	ShmFormatXrgb4444 ShmFormat = 0x32315258
	// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	ShmFormatXbgr4444 ShmFormat = 0x32314258
	// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	ShmFormatRgbx4444 ShmFormat = 0x32315852
	// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	ShmFormatBgrx4444 ShmFormat = 0x32315842
	// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	ShmFormatArgb4444 ShmFormat = 0x32315241
	// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	ShmFormatAbgr4444 ShmFormat = 0x32314241
	// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	ShmFormatRgba4444 ShmFormat = 0x32314152
	// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	ShmFormatBgra4444 ShmFormat = 0x32314142
	// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	ShmFormatXrgb1555 ShmFormat = 0x35315258
	// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	ShmFormatXbgr1555 ShmFormat = 0x35314258
	// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	ShmFormatRgbx5551 ShmFormat = 0x35315852
	// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	ShmFormatBgrx5551 ShmFormat = 0x35315842
	// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	ShmFormatArgb1555 ShmFormat = 0x35315241
	// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	ShmFormatAbgr1555 ShmFormat = 0x35314241
	// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	ShmFormatRgba5551 ShmFormat = 0x35314152
	// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	ShmFormatBgra5551 ShmFormat = 0x35314142
	// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	ShmFormatRgb565 ShmFormat = 0x36314752
	// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	ShmFormatBgr565 ShmFormat = 0x36314742
	// 24-bit RGB format, [23:0] R:G:B little endian
	ShmFormatRgb888 ShmFormat = 0x34324752
	// 24-bit BGR format, [23:0] B:G:R little endian
	ShmFormatBgr888 ShmFormat = 0x34324742
	// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	ShmFormatXbgr8888 ShmFormat = 0x34324258
	// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	ShmFormatRgbx8888 ShmFormat = 0x34325852
	// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	ShmFormatBgrx8888 ShmFormat = 0x34325842
	// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	ShmFormatAbgr8888 ShmFormat = 0x34324241
	// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	ShmFormatRgba8888 ShmFormat = 0x34324152
	// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	ShmFormatBgra8888 ShmFormat = 0x34324142
	// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	ShmFormatXrgb2101010 ShmFormat = 0x30335258
	// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	ShmFormatXbgr2101010 ShmFormat = 0x30334258
	// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	ShmFormatRgbx1010102 ShmFormat = 0x30335852
	// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	ShmFormatBgrx1010102 ShmFormat = 0x30335842
	// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	ShmFormatArgb2101010 ShmFormat = 0x30335241
	// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	ShmFormatAbgr2101010 ShmFormat = 0x30334241
	// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	ShmFormatRgba1010102 ShmFormat = 0x30334152
	// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	ShmFormatBgra1010102 ShmFormat = 0x30334142
	// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	ShmFormatYuyv ShmFormat = 0x56595559
	// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	ShmFormatYvyu ShmFormat = 0x55595659
	// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	ShmFormatUyvy ShmFormat = 0x59565955
	// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	ShmFormatVyuy ShmFormat = 0x59555956
	// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	ShmFormatAyuv ShmFormat = 0x56555941
	// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	ShmFormatNv12 ShmFormat = 0x3231564e
	// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	ShmFormatNv21 ShmFormat = 0x3132564e
	// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	ShmFormatNv16 ShmFormat = 0x3631564e
	// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	ShmFormatNv61 ShmFormat = 0x3136564e
	// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv410 ShmFormat = 0x39565559
	// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu410 ShmFormat = 0x39555659
	// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv411 ShmFormat = 0x31315559
	// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu411 ShmFormat = 0x31315659
	// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv420 ShmFormat = 0x32315559
	// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu420 ShmFormat = 0x32315659
	// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv422 ShmFormat = 0x36315559
	// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu422 ShmFormat = 0x36315659
	// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv444 ShmFormat = 0x34325559
	// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu444 ShmFormat = 0x34325659
	// [7:0] R
	ShmFormatR8 ShmFormat = 0x20203852
	// [15:0] R little endian
	ShmFormatR16 ShmFormat = 0x20363152
	// [15:0] R:G 8:8 little endian
	ShmFormatRg88 ShmFormat = 0x38384752
	// [15:0] G:R 8:8 little endian
	ShmFormatGr88 ShmFormat = 0x38385247
	// [31:0] R:G 16:16 little endian
	ShmFormatRg1616 ShmFormat = 0x32334752
	// [31:0] G:R 16:16 little endian
	ShmFormatGr1616 ShmFormat = 0x32335247
	// [63:0] x:R:G:B 16:16:16:16 little endian
	ShmFormatXrgb16161616f ShmFormat = 0x48345258
	// [63:0] x:B:G:R 16:16:16:16 little endian
	ShmFormatXbgr16161616f ShmFormat = 0x48344258
	// [63:0] A:R:G:B 16:16:16:16 little endian
	ShmFormatArgb16161616f ShmFormat = 0x48345241
	// [63:0] A:B:G:R 16:16:16:16 little endian
	ShmFormatAbgr16161616f ShmFormat = 0x48344241
	// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	ShmFormatXyuv8888 ShmFormat = 0x56555958
	// [23:0] Cr:Cb:Y 8:8:8 little endian
	ShmFormatVuy888 ShmFormat = 0x34325556
	// Y followed by U then V, 10:10:10. Non-linear modifier only
	ShmFormatVuy101010 ShmFormat = 0x30335556
	// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	ShmFormatY210 ShmFormat = 0x30313259
	// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	ShmFormatY212 ShmFormat = 0x32313259
	// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	ShmFormatY216 ShmFormat = 0x36313259
	// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	ShmFormatY410 ShmFormat = 0x30313459
	// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	ShmFormatY412 ShmFormat = 0x32313459
	// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	ShmFormatY416 ShmFormat = 0x36313459
	// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	ShmFormatXvyu2101010 ShmFormat = 0x30335658
	// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	ShmFormatXvyu1216161616 ShmFormat = 0x36335658
	// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	ShmFormatXvyu16161616 ShmFormat = 0x38345658
	// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	ShmFormatY0l0 ShmFormat = 0x304c3059
	// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	ShmFormatX0l0 ShmFormat = 0x304c3058
	// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	ShmFormatY0l2 ShmFormat = 0x324c3059
	// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	ShmFormatX0l2        ShmFormat = 0x324c3058
	ShmFormatYuv4208bit  ShmFormat = 0x38305559
	ShmFormatYuv42010bit ShmFormat = 0x30315559
	ShmFormatXrgb8888A8  ShmFormat = 0x38415258
	ShmFormatXbgr8888A8  ShmFormat = 0x38414258
	ShmFormatRgbx8888A8  ShmFormat = 0x38415852
	ShmFormatBgrx8888A8  ShmFormat = 0x38415842
	ShmFormatRgb888A8    ShmFormat = 0x38413852
	ShmFormatBgr888A8    ShmFormat = 0x38413842
	ShmFormatRgb565A8    ShmFormat = 0x38413552
	ShmFormatBgr565A8    ShmFormat = 0x38413542
	// non-subsampled Cr:Cb plane
	ShmFormatNv24 ShmFormat = 0x3432564e
	// non-subsampled Cb:Cr plane
	ShmFormatNv42 ShmFormat = 0x3234564e
	// 2x1 subsampled Cr:Cb plane, 10 bit per channel
	ShmFormatP210 ShmFormat = 0x30313250
	// 2x2 subsampled Cr:Cb plane 10 bits per channel
	ShmFormatP010 ShmFormat = 0x30313050
	// 2x2 subsampled Cr:Cb plane 12 bits per channel
	ShmFormatP012 ShmFormat = 0x32313050
	// 2x2 subsampled Cr:Cb plane 16 bits per channel
	ShmFormatP016 ShmFormat = 0x36313050
	// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	ShmFormatAxbxgxrx106106106106 ShmFormat = 0x30314241
	// 2x2 subsampled Cr:Cb plane
	ShmFormatNv15 ShmFormat = 0x3531564e
	ShmFormatQ410 ShmFormat = 0x30313451
	ShmFormatQ401 ShmFormat = 0x31303451
	// [63:0] x:R:G:B 16:16:16:16 little endian
	ShmFormatXrgb16161616 ShmFormat = 0x38345258
	// [63:0] x:B:G:R 16:16:16:16 little endian
	ShmFormatXbgr16161616 ShmFormat = 0x38344258
	// [63:0] A:R:G:B 16:16:16:16 little endian
	ShmFormatArgb16161616 ShmFormat = 0x38345241
	// [63:0] A:B:G:R 16:16:16:16 little endian
	ShmFormatAbgr16161616 ShmFormat = 0x38344241
)

var ShmInterface = &wlproto.Interface{
	Name:    "wl_shm",
	Version: 1,
	Type:    reflect.TypeOf(Shm{}),
	Requests: []wlproto.Request{
		{
			Name:   "create_pool",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShmImplementation.CreatePool),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(ShmPool{})},
				{Type: wlproto.ArgTypeFd},
				{Type: wlproto.ArgTypeInt},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "format",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShmFormat(0))},
			},
		},
	},
}

// A singleton global object that provides support for shared
// memory.
//
// Clients can create wl_shm_pool objects using the create_pool
// request.
//
// At connection setup time, the wl_shm object emits one or more
// format events to inform clients about the valid pixel formats
// that can be used for buffers.
type Shm struct{ wlserver.Resource }

func (Shm) Interface() *wlproto.Interface { return ShmInterface }

type ShmImplementation interface {
	CreatePool(obj Shm, id ShmPool, fd uintptr, size int32) ShmPoolImplementation
}

func AddShmGlobal(dsp *wlserver.Display, version int, bind func(res Shm) ShmImplementation) {
	dsp.AddGlobal(ShmInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Shm)) })
}

// Informs the client about a valid pixel format that
// can be used for buffers. Known formats include
// argb8888 and xrgb8888.
func (obj Shm) Format(format ShmFormat) {
	obj.Conn().SendEvent(obj, 0, format)
}

var BufferInterface = &wlproto.Interface{
	Name:    "wl_buffer",
	Version: 1,
	Type:    reflect.TypeOf(Buffer{}),
	Requests: []wlproto.Request{
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(BufferImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "release",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
	},
}

// A buffer provides the content for a wl_surface. Buffers are
// created through factory interfaces such as wl_shm, wp_linux_buffer_params
// (from the linux-dmabuf protocol extension) or similar. It has a width and
// a height and can be attached to a wl_surface, but the mechanism by which a
// client provides and updates the contents is defined by the buffer factory
// interface.
//
// If the buffer uses a format that has an alpha channel, the alpha channel
// is assumed to be premultiplied in the color channels unless otherwise
// specified.
type Buffer struct{ wlserver.Resource }

func (Buffer) Interface() *wlproto.Interface { return BufferInterface }

type BufferImplementation interface {
	Destroy(obj Buffer)
}

func AddBufferGlobal(dsp *wlserver.Display, version int, bind func(res Buffer) BufferImplementation) {
	dsp.AddGlobal(BufferInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Buffer)) })
}

// Sent when this wl_buffer is no longer used by the compositor.
// The client is now free to reuse or destroy this buffer and its
// backing storage.
//
// If a client receives a release event before the frame callback
// requested in the same wl_surface.commit that attaches this
// wl_buffer to a surface, then the client is immediately free to
// reuse the buffer and its backing storage, and does not need a
// second buffer for the next surface content update. Typically
// this is possible, when the compositor maintains a copy of the
// wl_surface contents, e.g. as a GL texture. This is an important
// optimization for GL(ES) compositors with wl_shm clients.
func (obj Buffer) Release() {
	obj.Conn().SendEvent(obj, 0)
}

type DataOfferError uint32

const (
	// finish request was called untimely
	DataOfferErrorInvalidFinish DataOfferError = 0
	// action mask contains invalid values
	DataOfferErrorInvalidActionMask DataOfferError = 1
	// action argument has an invalid value
	DataOfferErrorInvalidAction DataOfferError = 2
	// offer doesn't accept this request
	DataOfferErrorInvalidOffer DataOfferError = 3
)

var DataOfferInterface = &wlproto.Interface{
	Name:    "wl_data_offer",
	Version: 3,
	Type:    reflect.TypeOf(DataOffer{}),
	Requests: []wlproto.Request{
		{
			Name:   "accept",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataOfferImplementation.Accept),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:   "receive",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataOfferImplementation.Receive),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
				{Type: wlproto.ArgTypeFd},
			},
		},
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(DataOfferImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "finish",
			Type:   "",
			Since:  3,
			Method: reflect.ValueOf(DataOfferImplementation.Finish),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "set_actions",
			Type:   "",
			Since:  3,
			Method: reflect.ValueOf(DataOfferImplementation.SetActions),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(DataDeviceManagerDndAction(0))},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(DataDeviceManagerDndAction(0))},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "offer",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:  "source_actions",
			Since: 3,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(DataDeviceManagerDndAction(0))},
			},
		},
		{
			Name:  "action",
			Since: 3,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(DataDeviceManagerDndAction(0))},
			},
		},
	},
}

// A wl_data_offer represents a piece of data offered for transfer
// by another client (the source client).  It is used by the
// copy-and-paste and drag-and-drop mechanisms.  The offer
// describes the different mime types that the data can be
// converted to and provides the mechanism for transferring the
// data directly from the source client.
type DataOffer struct{ wlserver.Resource }

func (DataOffer) Interface() *wlproto.Interface { return DataOfferInterface }

type DataOfferImplementation interface {
	Accept(obj DataOffer, serial uint32, mimeType string)
	Receive(obj DataOffer, mimeType string, fd uintptr)
	Destroy(obj DataOffer)
	Finish(obj DataOffer)
	SetActions(obj DataOffer, dndActions DataDeviceManagerDndAction, preferredAction DataDeviceManagerDndAction)
}

func AddDataOfferGlobal(dsp *wlserver.Display, version int, bind func(res DataOffer) DataOfferImplementation) {
	dsp.AddGlobal(DataOfferInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(DataOffer)) })
}

// Sent immediately after creating the wl_data_offer object.  One
// event per offered mime type.
func (obj DataOffer) Offer(mimeType string) {
	obj.Conn().SendEvent(obj, 0, mimeType)
}

// This event indicates the actions offered by the data source. It
// will be sent right after wl_data_device.enter, or anytime the source
// side changes its offered actions through wl_data_source.set_actions.
func (obj DataOffer) SourceActions(sourceActions DataDeviceManagerDndAction) {
	obj.Conn().SendEvent(obj, 1, sourceActions)
}

// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation in response to destination side action changes through
// wl_data_offer.set_actions.
//
// This event will no longer be emitted after wl_data_device.drop
// happened on the drag-and-drop destination, the client must
// honor the last action received, or the last preferred one set
// through wl_data_offer.set_actions when handling an "ask" action.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. Prior to
// receiving wl_data_device.drop, the chosen action may change (e.g.
// due to keyboard modifiers being pressed). At the time of receiving
// wl_data_device.drop the drag-and-drop destination must honor the
// last action received.
//
// Action changes may still happen after wl_data_device.drop,
// especially on "ask" actions, where the drag-and-drop destination
// may choose another action afterwards. Action changes happening
// at this stage are always the result of inter-client negotiation, the
// compositor shall no longer be able to induce a different action.
//
// Upon "ask" actions, it is expected that the drag-and-drop destination
// may potentially choose a different action and/or mime type,
// based on wl_data_offer.source_actions and finally chosen by the
// user (e.g. popping up a menu with the available options). The
// final wl_data_offer.set_actions and wl_data_offer.accept requests
// must happen before the call to wl_data_offer.finish.
func (obj DataOffer) Action(dndAction DataDeviceManagerDndAction) {
	obj.Conn().SendEvent(obj, 2, dndAction)
}

type DataSourceError uint32

const (
	// action mask contains invalid values
	DataSourceErrorInvalidActionMask DataSourceError = 0
	// source doesn't accept this request
	DataSourceErrorInvalidSource DataSourceError = 1
)

var DataSourceInterface = &wlproto.Interface{
	Name:    "wl_data_source",
	Version: 3,
	Type:    reflect.TypeOf(DataSource{}),
	Requests: []wlproto.Request{
		{
			Name:   "offer",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataSourceImplementation.Offer),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(DataSourceImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "set_actions",
			Type:   "",
			Since:  3,
			Method: reflect.ValueOf(DataSourceImplementation.SetActions),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(DataDeviceManagerDndAction(0))},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "target",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:  "send",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
				{Type: wlproto.ArgTypeFd},
			},
		},
		{
			Name:  "cancelled",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "dnd_drop_performed",
			Since: 3,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "dnd_finished",
			Since: 3,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "action",
			Since: 3,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(DataDeviceManagerDndAction(0))},
			},
		},
	},
}

// The wl_data_source object is the source side of a wl_data_offer.
// It is created by the source client in a data transfer and
// provides a way to describe the offered data and a way to respond
// to requests to transfer the data.
type DataSource struct{ wlserver.Resource }

func (DataSource) Interface() *wlproto.Interface { return DataSourceInterface }

type DataSourceImplementation interface {
	Offer(obj DataSource, mimeType string)
	Destroy(obj DataSource)
	SetActions(obj DataSource, dndActions DataDeviceManagerDndAction)
}

func AddDataSourceGlobal(dsp *wlserver.Display, version int, bind func(res DataSource) DataSourceImplementation) {
	dsp.AddGlobal(DataSourceInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(DataSource)) })
}

// Sent when a target accepts pointer_focus or motion events.  If
// a target does not accept any of the offered types, type is NULL.
//
// Used for feedback during drag-and-drop.
func (obj DataSource) Target(mimeType string) {
	obj.Conn().SendEvent(obj, 0, mimeType)
}

// Request for data from the client.  Send the data as the
// specified mime type over the passed file descriptor, then
// close it.
func (obj DataSource) Send(mimeType string, fd uintptr) {
	obj.Conn().SendEvent(obj, 1, mimeType, fd)
}

// This data source is no longer valid. There are several reasons why
// this could happen:
//
// - The data source has been replaced by another data source.
// - The drag-and-drop operation was performed, but the drop destination
// did not accept any of the mime types offered through
// wl_data_source.target.
// - The drag-and-drop operation was performed, but the drop destination
// did not select any of the actions present in the mask offered through
// wl_data_source.action.
// - The drag-and-drop operation was performed but didn't happen over a
// surface.
// - The compositor cancelled the drag-and-drop operation (e.g. compositor
// dependent timeouts to avoid stale drag-and-drop transfers).
//
// The client should clean up and destroy this data source.
//
// For objects of version 2 or older, wl_data_source.cancelled will
// only be emitted if the data source was replaced by another data
// source.
func (obj DataSource) Cancelled() {
	obj.Conn().SendEvent(obj, 2)
}

// The user performed the drop action. This event does not indicate
// acceptance, wl_data_source.cancelled may still be emitted afterwards
// if the drop destination does not accept any mime type.
//
// However, this event might however not be received if the compositor
// cancelled the drag-and-drop operation before this event could happen.
//
// Note that the data_source may still be used in the future and should
// not be destroyed here.
func (obj DataSource) DndDropPerformed() {
	obj.Conn().SendEvent(obj, 3)
}

// The drop destination finished interoperating with this data
// source, so the client is now free to destroy this data source and
// free all associated data.
//
// If the action used to perform the operation was "move", the
// source can now delete the transferred data.
func (obj DataSource) DndFinished() {
	obj.Conn().SendEvent(obj, 4)
}

// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation, mainly in response to destination side changes through
// wl_data_offer.set_actions, and as the data device enters/leaves
// surfaces.
//
// It is only possible to receive this event after
// wl_data_source.dnd_drop_performed if the drag-and-drop operation
// ended in an "ask" action, in which case the final wl_data_source.action
// event will happen immediately before wl_data_source.dnd_finished.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. The chosen
// action may change alongside negotiation (e.g. an "ask" action can turn
// into a "move" operation), so the effects of the final action must
// always be applied in wl_data_offer.dnd_finished.
//
// Clients can trigger cursor surface changes from this point, so
// they reflect the current action.
func (obj DataSource) Action(dndAction DataDeviceManagerDndAction) {
	obj.Conn().SendEvent(obj, 5, dndAction)
}

type DataDeviceError uint32

const (
	// given wl_surface has another role
	DataDeviceErrorRole DataDeviceError = 0
)

var DataDeviceInterface = &wlproto.Interface{
	Name:    "wl_data_device",
	Version: 3,
	Type:    reflect.TypeOf(DataDevice{}),
	Requests: []wlproto.Request{
		{
			Name:   "start_drag",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataDeviceImplementation.StartDrag),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(DataSource{})},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:   "set_selection",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataDeviceImplementation.SetSelection),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(DataSource{})},
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:   "release",
			Type:   "destructor",
			Since:  2,
			Method: reflect.ValueOf(DataDeviceImplementation.Release),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "data_offer",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(DataOffer{})},
			},
		},
		{
			Name:  "enter",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(DataOffer{})},
			},
		},
		{
			Name:  "leave",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "motion",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "drop",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "selection",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(DataOffer{})},
			},
		},
	},
}

// There is one wl_data_device per seat which can be obtained
// from the global wl_data_device_manager singleton.
//
// A wl_data_device provides access to inter-client data transfer
// mechanisms such as copy-and-paste and drag-and-drop.
type DataDevice struct{ wlserver.Resource }

func (DataDevice) Interface() *wlproto.Interface { return DataDeviceInterface }

type DataDeviceImplementation interface {
	StartDrag(obj DataDevice, source DataSource, origin Surface, icon Surface, serial uint32)
	SetSelection(obj DataDevice, source DataSource, serial uint32)
	Release(obj DataDevice)
}

func AddDataDeviceGlobal(dsp *wlserver.Display, version int, bind func(res DataDevice) DataDeviceImplementation) {
	dsp.AddGlobal(DataDeviceInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(DataDevice)) })
}

// The data_offer event introduces a new wl_data_offer object,
// which will subsequently be used in either the
// data_device.enter event (for drag-and-drop) or the
// data_device.selection event (for selections).  Immediately
// following the data_device_data_offer event, the new data_offer
// object will send out data_offer.offer events to describe the
// mime types it offers.
func (obj DataDevice) DataOffer(id DataOffer) {
	obj.Conn().SendEvent(obj, 0, id)
}

// This event is sent when an active drag-and-drop pointer enters
// a surface owned by the client.  The position of the pointer at
// enter time is provided by the x and y arguments, in surface-local
// coordinates.
func (obj DataDevice) Enter(serial uint32, surface Surface, x wlshared.Fixed, y wlshared.Fixed, id DataOffer) {
	obj.Conn().SendEvent(obj, 1, serial, surface, x, y, id)
}

// This event is sent when the drag-and-drop pointer leaves the
// surface and the session ends.  The client must destroy the
// wl_data_offer introduced at enter time at this point.
func (obj DataDevice) Leave() {
	obj.Conn().SendEvent(obj, 2)
}

// This event is sent when the drag-and-drop pointer moves within
// the currently focused surface. The new position of the pointer
// is provided by the x and y arguments, in surface-local
// coordinates.
func (obj DataDevice) Motion(time uint32, x wlshared.Fixed, y wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 3, time, x, y)
}

// The event is sent when a drag-and-drop operation is ended
// because the implicit grab is removed.
//
// The drag-and-drop destination is expected to honor the last action
// received through wl_data_offer.action, if the resulting action is
// "copy" or "move", the destination can still perform
// wl_data_offer.receive requests, and is expected to end all
// transfers with a wl_data_offer.finish request.
//
// If the resulting action is "ask", the action will not be considered
// final. The drag-and-drop destination is expected to perform one last
// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
// to cancel the operation.
func (obj DataDevice) Drop() {
	obj.Conn().SendEvent(obj, 4)
}

// The selection event is sent out to notify the client of a new
// wl_data_offer for the selection for this device.  The
// data_device.data_offer and the data_offer.offer events are
// sent out immediately before this event to introduce the data
// offer object.  The selection event is sent to a client
// immediately before receiving keyboard focus and when a new
// selection is set while the client has keyboard focus.  The
// data_offer is valid until a new data_offer or NULL is received
// or until the client loses keyboard focus.  Switching surface with
// keyboard focus within the same client doesn't mean a new selection
// will be sent.  The client must destroy the previous selection
// data_offer, if any, upon receiving this event.
func (obj DataDevice) Selection(id DataOffer) {
	obj.Conn().SendEvent(obj, 5, id)
}

// This is a bitmask of the available/preferred actions in a
// drag-and-drop operation.
//
// In the compositor, the selected action is a result of matching the
// actions offered by the source and destination sides.  "action" events
// with a "none" action will be sent to both source and destination if
// there is no match. All further checks will effectively happen on
// (source actions ∩ destination actions).
//
// In addition, compositors may also pick different actions in
// reaction to key modifiers being pressed. One common design that
// is used in major toolkits (and the behavior recommended for
// compositors) is:
//
// - If no modifiers are pressed, the first match (in bit order)
// will be used.
// - Pressing Shift selects "move", if enabled in the mask.
// - Pressing Control selects "copy", if enabled in the mask.
//
// Behavior beyond that is considered implementation-dependent.
// Compositors may for example bind other modifiers (like Alt/Meta)
// or drags initiated with other buttons than BTN_LEFT to specific
// actions (e.g. "ask").
type DataDeviceManagerDndAction uint32

const (
	// no action
	DataDeviceManagerDndActionNone DataDeviceManagerDndAction = 0
	// copy action
	DataDeviceManagerDndActionCopy DataDeviceManagerDndAction = 1
	// move action
	DataDeviceManagerDndActionMove DataDeviceManagerDndAction = 2
	// ask action
	DataDeviceManagerDndActionAsk DataDeviceManagerDndAction = 4
)

var DataDeviceManagerInterface = &wlproto.Interface{
	Name:    "wl_data_device_manager",
	Version: 3,
	Type:    reflect.TypeOf(DataDeviceManager{}),
	Requests: []wlproto.Request{
		{
			Name:   "create_data_source",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataDeviceManagerImplementation.CreateDataSource),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(DataSource{})},
			},
		},
		{
			Name:   "get_data_device",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(DataDeviceManagerImplementation.GetDataDevice),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(DataDevice{})},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Seat{})},
			},
		},
	},
	Events: []wlproto.Event{},
}

// The wl_data_device_manager is a singleton global object that
// provides access to inter-client data transfer mechanisms such as
// copy-and-paste and drag-and-drop.  These mechanisms are tied to
// a wl_seat and this interface lets a client get a wl_data_device
// corresponding to a wl_seat.
//
// Depending on the version bound, the objects created from the bound
// wl_data_device_manager object will have different requirements for
// functioning properly. See wl_data_source.set_actions,
// wl_data_offer.accept and wl_data_offer.finish for details.
type DataDeviceManager struct{ wlserver.Resource }

func (DataDeviceManager) Interface() *wlproto.Interface { return DataDeviceManagerInterface }

type DataDeviceManagerImplementation interface {
	CreateDataSource(obj DataDeviceManager, id DataSource) DataSourceImplementation
	GetDataDevice(obj DataDeviceManager, id DataDevice, seat Seat) DataDeviceImplementation
}

func AddDataDeviceManagerGlobal(dsp *wlserver.Display, version int, bind func(res DataDeviceManager) DataDeviceManagerImplementation) {
	dsp.AddGlobal(DataDeviceManagerInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(DataDeviceManager)) })
}

type ShellError uint32

const (
	// given wl_surface has another role
	ShellErrorRole ShellError = 0
)

var ShellInterface = &wlproto.Interface{
	Name:    "wl_shell",
	Version: 1,
	Type:    reflect.TypeOf(Shell{}),
	Requests: []wlproto.Request{
		{
			Name:   "get_shell_surface",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellImplementation.GetShellSurface),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(ShellSurface{})},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
			},
		},
	},
	Events: []wlproto.Event{},
}

// This interface is implemented by servers that provide
// desktop-style user interfaces.
//
// It allows clients to associate a wl_shell_surface with
// a basic surface.
//
// Note! This protocol is deprecated and not intended for production use.
// For desktop-style user interfaces, use xdg_shell.
type Shell struct{ wlserver.Resource }

func (Shell) Interface() *wlproto.Interface { return ShellInterface }

type ShellImplementation interface {
	GetShellSurface(obj Shell, id ShellSurface, surface Surface) ShellSurfaceImplementation
}

func AddShellGlobal(dsp *wlserver.Display, version int, bind func(res Shell) ShellImplementation) {
	dsp.AddGlobal(ShellInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Shell)) })
}

// These values are used to indicate which edge of a surface
// is being dragged in a resize operation. The server may
// use this information to adapt its behavior, e.g. choose
// an appropriate cursor image.
type ShellSurfaceResize uint32

const (
	// no edge
	ShellSurfaceResizeNone ShellSurfaceResize = 0
	// top edge
	ShellSurfaceResizeTop ShellSurfaceResize = 1
	// bottom edge
	ShellSurfaceResizeBottom ShellSurfaceResize = 2
	// left edge
	ShellSurfaceResizeLeft ShellSurfaceResize = 4
	// top and left edges
	ShellSurfaceResizeTopLeft ShellSurfaceResize = 5
	// bottom and left edges
	ShellSurfaceResizeBottomLeft ShellSurfaceResize = 6
	// right edge
	ShellSurfaceResizeRight ShellSurfaceResize = 8
	// top and right edges
	ShellSurfaceResizeTopRight ShellSurfaceResize = 9
	// bottom and right edges
	ShellSurfaceResizeBottomRight ShellSurfaceResize = 10
)

// These flags specify details of the expected behaviour
// of transient surfaces. Used in the set_transient request.
type ShellSurfaceTransient uint32

const (
	// do not set keyboard focus
	ShellSurfaceTransientInactive ShellSurfaceTransient = 0x1
)

// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type ShellSurfaceFullscreenMethod uint32

const (
	// no preference, apply default policy
	ShellSurfaceFullscreenMethodDefault ShellSurfaceFullscreenMethod = 0
	// scale, preserve the surface's aspect ratio and center on output
	ShellSurfaceFullscreenMethodScale ShellSurfaceFullscreenMethod = 1
	// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	ShellSurfaceFullscreenMethodDriver ShellSurfaceFullscreenMethod = 2
	// no upscaling, center on output and add black borders to compensate size mismatch
	ShellSurfaceFullscreenMethodFill ShellSurfaceFullscreenMethod = 3
)

var ShellSurfaceInterface = &wlproto.Interface{
	Name:    "wl_shell_surface",
	Version: 1,
	Type:    reflect.TypeOf(ShellSurface{}),
	Requests: []wlproto.Request{
		{
			Name:   "pong",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.Pong),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:   "move",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.Move),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Seat{})},
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:   "resize",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.Resize),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Seat{})},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShellSurfaceResize(0))},
			},
		},
		{
			Name:   "set_toplevel",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetToplevel),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "set_transient",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetTransient),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShellSurfaceTransient(0))},
			},
		},
		{
			Name:   "set_fullscreen",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetFullscreen),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShellSurfaceFullscreenMethod(0))},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Output{})},
			},
		},
		{
			Name:   "set_popup",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetPopup),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Seat{})},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShellSurfaceTransient(0))},
			},
		},
		{
			Name:   "set_maximized",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetMaximized),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Output{})},
			},
		},
		{
			Name:   "set_title",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetTitle),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:   "set_class",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(ShellSurfaceImplementation.SetClass),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "ping",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:  "configure",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(ShellSurfaceResize(0))},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:  "popup_done",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
	},
}

// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides requests to treat surfaces like toplevel, fullscreen
// or popup windows, move, resize or maximize them, associate
// metadata like title and class, etc.
//
// On the server side the object is automatically destroyed when
// the related wl_surface is destroyed. On the client side,
// wl_shell_surface_destroy() must be called before destroying
// the wl_surface object.
type ShellSurface struct{ wlserver.Resource }

func (ShellSurface) Interface() *wlproto.Interface { return ShellSurfaceInterface }

type ShellSurfaceImplementation interface {
	Pong(obj ShellSurface, serial uint32)
	Move(obj ShellSurface, seat Seat, serial uint32)
	Resize(obj ShellSurface, seat Seat, serial uint32, edges ShellSurfaceResize)
	SetToplevel(obj ShellSurface)
	SetTransient(obj ShellSurface, parent Surface, x int32, y int32, flags ShellSurfaceTransient)
	SetFullscreen(obj ShellSurface, method ShellSurfaceFullscreenMethod, framerate uint32, output Output)
	SetPopup(obj ShellSurface, seat Seat, serial uint32, parent Surface, x int32, y int32, flags ShellSurfaceTransient)
	SetMaximized(obj ShellSurface, output Output)
	SetTitle(obj ShellSurface, title string)
	SetClass(obj ShellSurface, class string)
}

func AddShellSurfaceGlobal(dsp *wlserver.Display, version int, bind func(res ShellSurface) ShellSurfaceImplementation) {
	dsp.AddGlobal(ShellSurfaceInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(ShellSurface)) })
}

// Ping a client to check if it is receiving events and sending
// requests. A client is expected to reply with a pong request.
func (obj ShellSurface) Ping(serial uint32) {
	obj.Conn().SendEvent(obj, 0, serial)
}

// The configure event asks the client to resize its surface.
//
// The size is a hint, in the sense that the client is free to
// ignore it if it doesn't resize, pick a smaller size (to
// satisfy aspect ratio or resize in steps of NxM pixels).
//
// The edges parameter provides a hint about how the surface
// was resized. The client may use this information to decide
// how to adjust its content to the new size (e.g. a scrolling
// area might adjust its content position to leave the viewable
// content unmoved).
//
// The client is free to dismiss all but the last configure
// event it received.
//
// The width and height arguments specify the size of the window
// in surface-local coordinates.
func (obj ShellSurface) Configure(edges ShellSurfaceResize, width int32, height int32) {
	obj.Conn().SendEvent(obj, 1, edges, width, height)
}

// The popup_done event is sent out when a popup grab is broken,
// that is, when the user clicks a surface that doesn't belong
// to the client owning the popup surface.
func (obj ShellSurface) PopupDone() {
	obj.Conn().SendEvent(obj, 2)
}

// These errors can be emitted in response to wl_surface requests.
type SurfaceError uint32

const (
	// buffer scale value is invalid
	SurfaceErrorInvalidScale SurfaceError = 0
	// buffer transform value is invalid
	SurfaceErrorInvalidTransform SurfaceError = 1
	// buffer size is invalid
	SurfaceErrorInvalidSize SurfaceError = 2
	// buffer offset is invalid
	SurfaceErrorInvalidOffset SurfaceError = 3
)

var SurfaceInterface = &wlproto.Interface{
	Name:    "wl_surface",
	Version: 5,
	Type:    reflect.TypeOf(Surface{}),
	Requests: []wlproto.Request{
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "attach",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.Attach),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Buffer{})},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "damage",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.Damage),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "frame",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.Frame),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Callback{})},
			},
		},
		{
			Name:   "set_opaque_region",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.SetOpaqueRegion),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Region{})},
			},
		},
		{
			Name:   "set_input_region",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.SetInputRegion),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Region{})},
			},
		},
		{
			Name:   "commit",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SurfaceImplementation.Commit),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "set_buffer_transform",
			Type:   "",
			Since:  2,
			Method: reflect.ValueOf(SurfaceImplementation.SetBufferTransform),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt, Aux: reflect.TypeOf(int32(0))},
			},
		},
		{
			Name:   "set_buffer_scale",
			Type:   "",
			Since:  3,
			Method: reflect.ValueOf(SurfaceImplementation.SetBufferScale),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "damage_buffer",
			Type:   "",
			Since:  4,
			Method: reflect.ValueOf(SurfaceImplementation.DamageBuffer),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "offset",
			Type:   "",
			Since:  5,
			Method: reflect.ValueOf(SurfaceImplementation.Offset),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "enter",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Output{})},
			},
		},
		{
			Name:  "leave",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Output{})},
			},
		},
	},
}

// A surface is a rectangular area that may be displayed on zero
// or more outputs, and shown any number of times at the compositor's
// discretion. They can present wl_buffers, receive user input, and
// define a local coordinate system.
//
// The size of a surface (and relative positions on it) is described
// in surface-local coordinates, which may differ from the buffer
// coordinates of the pixel content, in case a buffer_transform
// or a buffer_scale is used.
//
// A surface without a "role" is fairly useless: a compositor does
// not know where, when or how to present it. The role is the
// purpose of a wl_surface. Examples of roles are a cursor for a
// pointer (as set by wl_pointer.set_cursor), a drag icon
// (wl_data_device.start_drag), a sub-surface
// (wl_subcompositor.get_subsurface), and a window as defined by a
// shell protocol (e.g. wl_shell.get_shell_surface).
//
// A surface can have only one role at a time. Initially a
// wl_surface does not have a role. Once a wl_surface is given a
// role, it is set permanently for the whole lifetime of the
// wl_surface object. Giving the current role again is allowed,
// unless explicitly forbidden by the relevant interface
// specification.
//
// Surface roles are given by requests in other interfaces such as
// wl_pointer.set_cursor. The request should explicitly mention
// that this request gives a role to a wl_surface. Often, this
// request also creates a new protocol object that represents the
// role and adds additional functionality to wl_surface. When a
// client wants to destroy a wl_surface, they must destroy this 'role
// object' before the wl_surface.
//
// Destroying the role object does not remove the role from the
// wl_surface, but it may stop the wl_surface from "playing the role".
// For instance, if a wl_subsurface object is destroyed, the wl_surface
// it was created for will be unmapped and forget its position and
// z-order. It is allowed to create a wl_subsurface for the same
// wl_surface again, but it is not allowed to use the wl_surface as
// a cursor (cursor is a different role than sub-surface, and role
// switching is not allowed).
type Surface struct{ wlserver.Resource }

func (Surface) Interface() *wlproto.Interface { return SurfaceInterface }

type SurfaceImplementation interface {
	Destroy(obj Surface)
	Attach(obj Surface, buffer Buffer, x int32, y int32)
	Damage(obj Surface, x int32, y int32, width int32, height int32)
	Frame(obj Surface, callback Callback) CallbackImplementation
	SetOpaqueRegion(obj Surface, region Region)
	SetInputRegion(obj Surface, region Region)
	Commit(obj Surface)
	SetBufferTransform(obj Surface, transform int32)
	SetBufferScale(obj Surface, scale int32)
	DamageBuffer(obj Surface, x int32, y int32, width int32, height int32)
	Offset(obj Surface, x int32, y int32)
}

func AddSurfaceGlobal(dsp *wlserver.Display, version int, bind func(res Surface) SurfaceImplementation) {
	dsp.AddGlobal(SurfaceInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Surface)) })
}

// This is emitted whenever a surface's creation, movement, or resizing
// results in some part of it being within the scanout region of an
// output.
//
// Note that a surface may be overlapping with zero or more outputs.
func (obj Surface) Enter(output Output) {
	obj.Conn().SendEvent(obj, 0, output)
}

// This is emitted whenever a surface's creation, movement, or resizing
// results in it no longer having any part of it within the scanout region
// of an output.
//
// Clients should not use the number of outputs the surface is on for frame
// throttling purposes. The surface might be hidden even if no leave event
// has been sent, and the compositor might expect new surface content
// updates even if no enter event has been sent. The frame event should be
// used instead.
func (obj Surface) Leave(output Output) {
	obj.Conn().SendEvent(obj, 1, output)
}

// This is a bitmask of capabilities this seat has; if a member is
// set, then it is present on the seat.
type SeatCapability uint32

const (
	// the seat has pointer devices
	SeatCapabilityPointer SeatCapability = 1
	// the seat has one or more keyboards
	SeatCapabilityKeyboard SeatCapability = 2
	// the seat has touch devices
	SeatCapabilityTouch SeatCapability = 4
)

// These errors can be emitted in response to wl_seat requests.
type SeatError uint32

const (
	// get_pointer, get_keyboard or get_touch called on seat without the matching capability
	SeatErrorMissingCapability SeatError = 0
)

var SeatInterface = &wlproto.Interface{
	Name:    "wl_seat",
	Version: 7,
	Type:    reflect.TypeOf(Seat{}),
	Requests: []wlproto.Request{
		{
			Name:   "get_pointer",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SeatImplementation.GetPointer),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Pointer{})},
			},
		},
		{
			Name:   "get_keyboard",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SeatImplementation.GetKeyboard),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Keyboard{})},
			},
		},
		{
			Name:   "get_touch",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SeatImplementation.GetTouch),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Touch{})},
			},
		},
		{
			Name:   "release",
			Type:   "destructor",
			Since:  5,
			Method: reflect.ValueOf(SeatImplementation.Release),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "capabilities",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(SeatCapability(0))},
			},
		},
		{
			Name:  "name",
			Since: 2,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
	},
}

// A seat is a group of keyboards, pointer and touch devices. This
// object is published as a global during start up, or when such a
// device is hot plugged.  A seat typically has a pointer and
// maintains a keyboard focus and a pointer focus.
type Seat struct{ wlserver.Resource }

func (Seat) Interface() *wlproto.Interface { return SeatInterface }

type SeatImplementation interface {
	GetPointer(obj Seat, id Pointer) PointerImplementation
	GetKeyboard(obj Seat, id Keyboard) KeyboardImplementation
	GetTouch(obj Seat, id Touch) TouchImplementation
	Release(obj Seat)
}

func AddSeatGlobal(dsp *wlserver.Display, version int, bind func(res Seat) SeatImplementation) {
	dsp.AddGlobal(SeatInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Seat)) })
}

// This is emitted whenever a seat gains or loses the pointer,
// keyboard or touch capabilities.  The argument is a capability
// enum containing the complete set of capabilities this seat has.
//
// When the pointer capability is added, a client may create a
// wl_pointer object using the wl_seat.get_pointer request. This object
// will receive pointer events until the capability is removed in the
// future.
//
// When the pointer capability is removed, a client should destroy the
// wl_pointer objects associated with the seat where the capability was
// removed, using the wl_pointer.release request. No further pointer
// events will be received on these objects.
//
// In some compositors, if a seat regains the pointer capability and a
// client has a previously obtained wl_pointer object of version 4 or
// less, that object may start sending pointer events again. This
// behavior is considered a misinterpretation of the intended behavior
// and must not be relied upon by the client. wl_pointer objects of
// version 5 or later must not send events if created before the most
// recent event notifying the client of an added pointer capability.
//
// The above behavior also applies to wl_keyboard and wl_touch with the
// keyboard and touch capabilities, respectively.
func (obj Seat) Capabilities(capabilities SeatCapability) {
	obj.Conn().SendEvent(obj, 0, capabilities)
}

// In a multi-seat configuration the seat name can be used by clients to
// help identify which physical devices the seat represents.
//
// The seat name is a UTF-8 string with no convention defined for its
// contents. Each name is unique among all wl_seat globals. The name is
// only guaranteed to be unique for the current compositor instance.
//
// The same seat names are used for all clients. Thus, the name can be
// shared across processes to refer to a specific wl_seat global.
//
// The name event is sent after binding to the seat global. This event is
// only sent once per seat object, and the name does not change over the
// lifetime of the wl_seat global.
//
// Compositors may re-use the same seat name if the wl_seat global is
// destroyed and re-created later.
func (obj Seat) Name(name string) {
	obj.Conn().SendEvent(obj, 1, name)
}

type PointerError uint32

const (
	// given wl_surface has another role
	PointerErrorRole PointerError = 0
)

// Describes the physical state of a button that produced the button
// event.
type PointerButtonState uint32

const (
	// the button is not pressed
	PointerButtonStateReleased PointerButtonState = 0
	// the button is pressed
	PointerButtonStatePressed PointerButtonState = 1
)

// Describes the axis types of scroll events.
type PointerAxis uint32

const (
	// vertical axis
	PointerAxisVerticalScroll PointerAxis = 0
	// horizontal axis
	PointerAxisHorizontalScroll PointerAxis = 1
)

// Describes the source types for axis events. This indicates to the
// client how an axis event was physically generated; a client may
// adjust the user interface accordingly. For example, scroll events
// from a "finger" source may be in a smooth coordinate space with
// kinetic scrolling whereas a "wheel" source may be in discrete steps
// of a number of lines.
//
// The "continuous" axis source is a device generating events in a
// continuous coordinate space, but using something other than a
// finger. One example for this source is button-based scrolling where
// the vertical motion of a device is converted to scroll events while
// a button is held down.
//
// The "wheel tilt" axis source indicates that the actual device is a
// wheel but the scroll event is not caused by a rotation but a
// (usually sideways) tilt of the wheel.
type PointerAxisSource uint32

const (
	// a physical wheel rotation
	PointerAxisSourceWheel PointerAxisSource = 0
	// finger on a touch surface
	PointerAxisSourceFinger PointerAxisSource = 1
	// continuous coordinate space
	PointerAxisSourceContinuous PointerAxisSource = 2
	// a physical wheel tilt
	PointerAxisSourceWheelTilt PointerAxisSource = 3
)

var PointerInterface = &wlproto.Interface{
	Name:    "wl_pointer",
	Version: 7,
	Type:    reflect.TypeOf(Pointer{}),
	Requests: []wlproto.Request{
		{
			Name:   "set_cursor",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(PointerImplementation.SetCursor),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "release",
			Type:   "destructor",
			Since:  3,
			Method: reflect.ValueOf(PointerImplementation.Release),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "enter",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "leave",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
			},
		},
		{
			Name:  "motion",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "button",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(PointerButtonState(0))},
			},
		},
		{
			Name:  "axis",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(PointerAxis(0))},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "frame",
			Since: 5,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "axis_source",
			Since: 5,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(PointerAxisSource(0))},
			},
		},
		{
			Name:  "axis_stop",
			Since: 5,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(PointerAxis(0))},
			},
		},
		{
			Name:  "axis_discrete",
			Since: 5,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(PointerAxis(0))},
				{Type: wlproto.ArgTypeInt},
			},
		},
	},
}

// The wl_pointer interface represents one or more input devices,
// such as mice, which control the pointer location and pointer_focus
// of a seat.
//
// The wl_pointer interface generates motion, enter and leave
// events for the surfaces that the pointer is located over,
// and button and axis events for button presses, button releases
// and scrolling.
type Pointer struct{ wlserver.Resource }

func (Pointer) Interface() *wlproto.Interface { return PointerInterface }

type PointerImplementation interface {
	SetCursor(obj Pointer, serial uint32, surface Surface, hotspotX int32, hotspotY int32)
	Release(obj Pointer)
}

func AddPointerGlobal(dsp *wlserver.Display, version int, bind func(res Pointer) PointerImplementation) {
	dsp.AddGlobal(PointerInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Pointer)) })
}

// Notification that this seat's pointer is focused on a certain
// surface.
//
// When a seat's focus enters a surface, the pointer image
// is undefined and a client should respond to this event by setting
// an appropriate pointer image with the set_cursor request.
func (obj Pointer) Enter(serial uint32, surface Surface, surfaceX wlshared.Fixed, surfaceY wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 0, serial, surface, surfaceX, surfaceY)
}

// Notification that this seat's pointer is no longer focused on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
func (obj Pointer) Leave(serial uint32, surface Surface) {
	obj.Conn().SendEvent(obj, 1, serial, surface)
}

// Notification of pointer location change. The arguments
// surface_x and surface_y are the location relative to the
// focused surface.
func (obj Pointer) Motion(time uint32, surfaceX wlshared.Fixed, surfaceY wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 2, time, surfaceX, surfaceY)
}

// Mouse button click and release notifications.
//
// The location of the click is given by the last motion or
// enter event.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The button is a button code as defined in the Linux kernel's
// linux/input-event-codes.h header file, e.g. BTN_LEFT.
//
// Any 16-bit button code value is reserved for future additions to the
// kernel's event code list. All other button codes above 0xFFFF are
// currently undefined but may be used in future versions of this
// protocol.
func (obj Pointer) Button(serial uint32, time uint32, button uint32, state PointerButtonState) {
	obj.Conn().SendEvent(obj, 3, serial, time, button, state)
}

// Scroll and other axis notifications.
//
// For scroll events (vertical and horizontal scroll axes), the
// value parameter is the length of a vector along the specified
// axis in a coordinate space identical to those of motion events,
// representing a relative movement along the specified axis.
//
// For devices that support movements non-parallel to axes multiple
// axis events will be emitted.
//
// When applicable, for example for touch pads, the server can
// choose to emit scroll events where the motion vector is
// equivalent to a motion event vector.
//
// When applicable, a client can transform its content relative to the
// scroll distance.
func (obj Pointer) Axis(time uint32, axis PointerAxis, value wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 4, time, axis, value)
}

// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// All wl_pointer events before a wl_pointer.frame event belong
// logically together. For example, in a diagonal scroll motion the
// compositor will send an optional wl_pointer.axis_source event, two
// wl_pointer.axis events (horizontal and vertical) and finally a
// wl_pointer.frame event. The client may use this information to
// calculate a diagonal vector for scrolling.
//
// When multiple wl_pointer.axis events occur within the same frame,
// the motion vector is the combined motion of all events.
// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
// the same frame, this indicates that axis movement in one axis has
// stopped but continues in the other axis.
// When multiple wl_pointer.axis_stop events occur within the same
// frame, this indicates that these axes stopped in the same instance.
//
// A wl_pointer.frame event is sent for every logical event group,
// even if the group only contains a single wl_pointer event.
// Specifically, a client may get a sequence: motion, frame, button,
// frame, axis, frame, axis_stop, frame.
//
// The wl_pointer.enter and wl_pointer.leave events are logical events
// generated by the compositor and not the hardware. These events are
// also grouped by a wl_pointer.frame. When a pointer moves from one
// surface to another, a compositor should group the
// wl_pointer.leave event within the same wl_pointer.frame.
// However, a client must not rely on wl_pointer.leave and
// wl_pointer.enter being in the same wl_pointer.frame.
// Compositor-specific policies may require the wl_pointer.leave and
// wl_pointer.enter event being split across multiple wl_pointer.frame
// groups.
func (obj Pointer) Frame() {
	obj.Conn().SendEvent(obj, 5)
}

// Source information for scroll and other axes.
//
// This event does not occur on its own. It is sent before a
// wl_pointer.frame event and carries the source information for
// all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
// sent when the user lifts the finger off the device.
//
// If the source is wl_pointer.axis_source.wheel,
// wl_pointer.axis_source.wheel_tilt or
// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
// or may not be sent. Whether a compositor sends an axis_stop event
// for these sources is hardware-specific and implementation-dependent;
// clients must not rely on receiving an axis_stop event for these
// scroll sources and should treat scroll sequences from these scroll
// sources as unterminated by default.
//
// This event is optional. If the source is unknown for a particular
// axis event sequence, no event is sent.
// Only one wl_pointer.axis_source event is permitted per frame.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
func (obj Pointer) AxisSource(axisSource PointerAxisSource) {
	obj.Conn().SendEvent(obj, 6, axisSource)
}

// Stop notification for scroll and other axes.
//
// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
// is sent to notify a client that the axis sequence has terminated.
// This enables the client to implement kinetic scrolling.
// See the wl_pointer.axis_source documentation for information on when
// this event may be generated.
//
// Any wl_pointer.axis events with the same axis_source after this
// event should be considered as the start of a new axis motion.
//
// The timestamp is to be interpreted identical to the timestamp in the
// wl_pointer.axis event. The timestamp value may be the same as a
// preceding wl_pointer.axis event.
func (obj Pointer) AxisStop(time uint32, axis PointerAxis) {
	obj.Conn().SendEvent(obj, 7, time, axis)
}

// Discrete step information for scroll and other axes.
//
// This event carries the axis value of the wl_pointer.axis event in
// discrete steps (e.g. mouse wheel clicks).
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value on a
// continuous scale. The protocol guarantees that each axis_discrete
// event is always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_discrete and
// its coupled axis event, including other axis_discrete or axis
// events.
//
// This event is optional; continuous scrolling devices
// like two-finger scrolling on touchpads do not have discrete
// steps and do not generate this event.
//
// The discrete value carries the directional information. e.g. a value
// of -2 is two steps towards the negative direction of this axis.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
func (obj Pointer) AxisDiscrete(axis PointerAxis, discrete int32) {
	obj.Conn().SendEvent(obj, 8, axis, discrete)
}

// This specifies the format of the keymap provided to the
// client with the wl_keyboard.keymap event.
type KeyboardKeymapFormat uint32

const (
	// no keymap; client must understand how to interpret the raw keycode
	KeyboardKeymapFormatNoKeymap KeyboardKeymapFormat = 0
	// libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
	KeyboardKeymapFormatXkbV1 KeyboardKeymapFormat = 1
)

// Describes the physical state of a key that produced the key event.
type KeyboardKeyState uint32

const (
	// key is not pressed
	KeyboardKeyStateReleased KeyboardKeyState = 0
	// key is pressed
	KeyboardKeyStatePressed KeyboardKeyState = 1
)

var KeyboardInterface = &wlproto.Interface{
	Name:    "wl_keyboard",
	Version: 7,
	Type:    reflect.TypeOf(Keyboard{}),
	Requests: []wlproto.Request{
		{
			Name:   "release",
			Type:   "destructor",
			Since:  3,
			Method: reflect.ValueOf(KeyboardImplementation.Release),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "keymap",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(KeyboardKeymapFormat(0))},
				{Type: wlproto.ArgTypeFd},
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:  "enter",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeArray},
			},
		},
		{
			Name:  "leave",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
			},
		},
		{
			Name:  "key",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(KeyboardKeyState(0))},
			},
		},
		{
			Name:  "modifiers",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
			},
		},
		{
			Name:  "repeat_info",
			Since: 4,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
	},
}

// The wl_keyboard interface represents one or more keyboards
// associated with a seat.
type Keyboard struct{ wlserver.Resource }

func (Keyboard) Interface() *wlproto.Interface { return KeyboardInterface }

type KeyboardImplementation interface {
	Release(obj Keyboard)
}

func AddKeyboardGlobal(dsp *wlserver.Display, version int, bind func(res Keyboard) KeyboardImplementation) {
	dsp.AddGlobal(KeyboardInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Keyboard)) })
}

// This event provides a file descriptor to the client which can be
// memory-mapped in read-only mode to provide a keyboard mapping
// description.
//
// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
// the recipient, as MAP_SHARED may fail.
func (obj Keyboard) Keymap(format KeyboardKeymapFormat, fd uintptr, size uint32) {
	obj.Conn().SendEvent(obj, 0, format, fd, size)
}

// Notification that this seat's keyboard focus is on a certain
// surface.
//
// The compositor must send the wl_keyboard.modifiers event after this
// event.
func (obj Keyboard) Enter(serial uint32, surface Surface, keys []byte) {
	obj.Conn().SendEvent(obj, 1, serial, surface, keys)
}

// Notification that this seat's keyboard focus is no longer on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
// After this event client must assume that all keys, including modifiers,
// are lifted and also it must stop key repeating if there's some going on.
func (obj Keyboard) Leave(serial uint32, surface Surface) {
	obj.Conn().SendEvent(obj, 2, serial, surface)
}

// A key was pressed or released.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The key is a platform-specific key code that can be interpreted
// by feeding it to the keyboard mapping (see the keymap event).
//
// If this event produces a change in modifiers, then the resulting
// wl_keyboard.modifiers event must be sent after this event.
func (obj Keyboard) Key(serial uint32, time uint32, key uint32, state KeyboardKeyState) {
	obj.Conn().SendEvent(obj, 3, serial, time, key, state)
}

// Notifies clients that the modifier and/or group state has
// changed, and it should update its local state.
func (obj Keyboard) Modifiers(serial uint32, modsDepressed uint32, modsLatched uint32, modsLocked uint32, group uint32) {
	obj.Conn().SendEvent(obj, 4, serial, modsDepressed, modsLatched, modsLocked, group)
}

// Informs the client about the keyboard's repeat rate and delay.
//
// This event is sent as soon as the wl_keyboard object has been created,
// and is guaranteed to be received by the client before any key press
// event.
//
// Negative values for either rate or delay are illegal. A rate of zero
// will disable any repeating (regardless of the value of delay).
//
// This event can be sent later on as well with a new value if necessary,
// so clients should continue listening for the event past the creation
// of wl_keyboard.
func (obj Keyboard) RepeatInfo(rate int32, delay int32) {
	obj.Conn().SendEvent(obj, 5, rate, delay)
}

var TouchInterface = &wlproto.Interface{
	Name:    "wl_touch",
	Version: 7,
	Type:    reflect.TypeOf(Touch{}),
	Requests: []wlproto.Request{
		{
			Name:   "release",
			Type:   "destructor",
			Since:  3,
			Method: reflect.ValueOf(TouchImplementation.Release),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "down",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "up",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:  "motion",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "frame",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "cancel",
			Since: 1,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "shape",
			Since: 6,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeFixed},
				{Type: wlproto.ArgTypeFixed},
			},
		},
		{
			Name:  "orientation",
			Since: 6,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeFixed},
			},
		},
	},
}

// The wl_touch interface represents a touchscreen
// associated with a seat.
//
// Touch interactions can consist of one or more contacts.
// For each contact, a series of events is generated, starting
// with a down event, followed by zero or more motion events,
// and ending with an up event. Events relating to the same
// contact point can be identified by the ID of the sequence.
type Touch struct{ wlserver.Resource }

func (Touch) Interface() *wlproto.Interface { return TouchInterface }

type TouchImplementation interface {
	Release(obj Touch)
}

func AddTouchGlobal(dsp *wlserver.Display, version int, bind func(res Touch) TouchImplementation) {
	dsp.AddGlobal(TouchInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Touch)) })
}

// A new touch point has appeared on the surface. This touch point is
// assigned a unique ID. Future events from this touch point reference
// this ID. The ID ceases to be valid after a touch up event and may be
// reused in the future.
func (obj Touch) Down(serial uint32, time uint32, surface Surface, id int32, x wlshared.Fixed, y wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 0, serial, time, surface, id, x, y)
}

// The touch point has disappeared. No further events will be sent for
// this touch point and the touch point's ID is released and may be
// reused in a future touch down event.
func (obj Touch) Up(serial uint32, time uint32, id int32) {
	obj.Conn().SendEvent(obj, 1, serial, time, id)
}

// A touch point has changed coordinates.
func (obj Touch) Motion(time uint32, id int32, x wlshared.Fixed, y wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 2, time, id, x, y)
}

// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// A wl_touch.frame terminates at least one event but otherwise no
// guarantee is provided about the set of events within a frame. A client
// must assume that any state not updated in a frame is unchanged from the
// previously known state.
func (obj Touch) Frame() {
	obj.Conn().SendEvent(obj, 3)
}

// Sent if the compositor decides the touch stream is a global
// gesture. No further events are sent to the clients from that
// particular gesture. Touch cancellation applies to all touch points
// currently active on this client's surface. The client is
// responsible for finalizing the touch points, future touch points on
// this surface may reuse the touch point ID.
func (obj Touch) Cancel() {
	obj.Conn().SendEvent(obj, 4)
}

// Sent when a touchpoint has changed its shape.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.orientation may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.shape event for this touch ID but both events may occur within
// the same wl_touch.frame.
//
// A touchpoint shape is approximated by an ellipse through the major and
// minor axis length. The major axis length describes the longer diameter
// of the ellipse, while the minor axis length describes the shorter
// diameter. Major and minor are orthogonal and both are specified in
// surface-local coordinates. The center of the ellipse is always at the
// touchpoint location as reported by wl_touch.down or wl_touch.move.
//
// This event is only sent by the compositor if the touch device supports
// shape reports. The client has to make reasonable assumptions about the
// shape if it did not receive this event.
func (obj Touch) Shape(id int32, major wlshared.Fixed, minor wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 5, id, major, minor)
}

// Sent when a touchpoint has changed its orientation.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.shape may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.orientation event for this touch ID but both events may occur
// within the same wl_touch.frame.
//
// The orientation describes the clockwise angle of a touchpoint's major
// axis to the positive surface y-axis and is normalized to the -180 to
// +180 degree range. The granularity of orientation depends on the touch
// device, some devices only support binary rotation values between 0 and
// 90 degrees.
//
// This event is only sent by the compositor if the touch device supports
// orientation reports.
func (obj Touch) Orientation(id int32, orientation wlshared.Fixed) {
	obj.Conn().SendEvent(obj, 6, id, orientation)
}

// This enumeration describes how the physical
// pixels on an output are laid out.
type OutputSubpixel uint32

const (
	// unknown geometry
	OutputSubpixelUnknown OutputSubpixel = 0
	// no geometry
	OutputSubpixelNone OutputSubpixel = 1
	// horizontal RGB
	OutputSubpixelHorizontalRgb OutputSubpixel = 2
	// horizontal BGR
	OutputSubpixelHorizontalBgr OutputSubpixel = 3
	// vertical RGB
	OutputSubpixelVerticalRgb OutputSubpixel = 4
	// vertical BGR
	OutputSubpixelVerticalBgr OutputSubpixel = 5
)

// This describes the transform that a compositor will apply to a
// surface to compensate for the rotation or mirroring of an
// output device.
//
// The flipped values correspond to an initial flip around a
// vertical axis followed by rotation.
//
// The purpose is mainly to allow clients to render accordingly and
// tell the compositor, so that for fullscreen surfaces, the
// compositor will still be able to scan out directly from client
// surfaces.
type OutputTransform uint32

const (
	// no transform
	OutputTransformNormal OutputTransform = 0
	// 90 degrees counter-clockwise
	OutputTransform90 OutputTransform = 1
	// 180 degrees counter-clockwise
	OutputTransform180 OutputTransform = 2
	// 270 degrees counter-clockwise
	OutputTransform270 OutputTransform = 3
	// 180 degree flip around a vertical axis
	OutputTransformFlipped OutputTransform = 4
	// flip and rotate 90 degrees counter-clockwise
	OutputTransformFlipped90 OutputTransform = 5
	// flip and rotate 180 degrees counter-clockwise
	OutputTransformFlipped180 OutputTransform = 6
	// flip and rotate 270 degrees counter-clockwise
	OutputTransformFlipped270 OutputTransform = 7
)

// These flags describe properties of an output mode.
// They are used in the flags bitfield of the mode event.
type OutputMode uint32

const (
	// indicates this is the current mode
	OutputModeCurrent OutputMode = 0x1
	// indicates this is the preferred mode
	OutputModePreferred OutputMode = 0x2
)

var OutputInterface = &wlproto.Interface{
	Name:    "wl_output",
	Version: 4,
	Type:    reflect.TypeOf(Output{}),
	Requests: []wlproto.Request{
		{
			Name:   "release",
			Type:   "destructor",
			Since:  3,
			Method: reflect.ValueOf(OutputImplementation.Release),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{
		{
			Name:  "geometry",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt, Aux: reflect.TypeOf(int32(0))},
				{Type: wlproto.ArgTypeString},
				{Type: wlproto.ArgTypeString},
				{Type: wlproto.ArgTypeInt, Aux: reflect.TypeOf(int32(0))},
			},
		},
		{
			Name:  "mode",
			Since: 1,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeUint, Aux: reflect.TypeOf(OutputMode(0))},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:  "done",
			Since: 2,
			Args:  []wlproto.Arg{},
		},
		{
			Name:  "scale",
			Since: 2,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:  "name",
			Since: 4,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
		{
			Name:  "description",
			Since: 4,
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeString},
			},
		},
	},
}

// An output describes part of the compositor geometry.  The
// compositor works in the 'compositor coordinate system' and an
// output corresponds to a rectangular area in that space that is
// actually visible.  This typically corresponds to a monitor that
// displays part of the compositor space.  This object is published
// as global during start up, or when a monitor is hotplugged.
type Output struct{ wlserver.Resource }

func (Output) Interface() *wlproto.Interface { return OutputInterface }

type OutputImplementation interface {
	Release(obj Output)
}

func AddOutputGlobal(dsp *wlserver.Display, version int, bind func(res Output) OutputImplementation) {
	dsp.AddGlobal(OutputInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Output)) })
}

// The geometry event describes geometric properties of the output.
// The event is sent when binding to the output object and whenever
// any of the properties change.
//
// The physical size can be set to zero if it doesn't make sense for this
// output (e.g. for projectors or virtual outputs).
//
// The geometry event will be followed by a done event (starting from
// version 2).
//
// Note: wl_output only advertises partial information about the output
// position and identification. Some compositors, for instance those not
// implementing a desktop-style output layout or those exposing virtual
// outputs, might fake this information. Instead of using x and y, clients
// should use xdg_output.logical_position. Instead of using make and model,
// clients should use name and description.
func (obj Output) Geometry(x int32, y int32, physicalWidth int32, physicalHeight int32, subpixel int32, make string, model string, transform int32) {
	obj.Conn().SendEvent(obj, 0, x, y, physicalWidth, physicalHeight, subpixel, make, model, transform)
}

// The mode event describes an available mode for the output.
//
// The event is sent when binding to the output object and there
// will always be one mode, the current mode.  The event is sent
// again if an output changes mode, for the mode that is now
// current.  In other words, the current mode is always the last
// mode that was received with the current flag set.
//
// Non-current modes are deprecated. A compositor can decide to only
// advertise the current mode and never send other modes. Clients
// should not rely on non-current modes.
//
// The size of a mode is given in physical hardware units of
// the output device. This is not necessarily the same as
// the output size in the global compositor space. For instance,
// the output may be scaled, as described in wl_output.scale,
// or transformed, as described in wl_output.transform. Clients
// willing to retrieve the output size in the global compositor
// space should use xdg_output.logical_size instead.
//
// The vertical refresh rate can be set to zero if it doesn't make
// sense for this output (e.g. for virtual outputs).
//
// The mode event will be followed by a done event (starting from
// version 2).
//
// Clients should not use the refresh rate to schedule frames. Instead,
// they should use the wl_surface.frame event or the presentation-time
// protocol.
//
// Note: this information is not always meaningful for all outputs. Some
// compositors, such as those exposing virtual outputs, might fake the
// refresh rate or the size.
func (obj Output) Mode(flags OutputMode, width int32, height int32, refresh int32) {
	obj.Conn().SendEvent(obj, 1, flags, width, height, refresh)
}

// This event is sent after all other properties have been
// sent after binding to the output object and after any
// other property changes done after that. This allows
// changes to the output properties to be seen as
// atomic, even if they happen via multiple events.
func (obj Output) Done() {
	obj.Conn().SendEvent(obj, 2)
}

// This event contains scaling geometry information
// that is not in the geometry event. It may be sent after
// binding the output object or if the output scale changes
// later. If it is not sent, the client should assume a
// scale of 1.
//
// A scale larger than 1 means that the compositor will
// automatically scale surface buffers by this amount
// when rendering. This is used for very high resolution
// displays where applications rendering at the native
// resolution would be too small to be legible.
//
// It is intended that scaling aware clients track the
// current output of a surface, and if it is on a scaled
// output it should use wl_surface.set_buffer_scale with
// the scale of the output. That way the compositor can
// avoid scaling the surface, and the client can supply
// a higher detail image.
//
// The scale event will be followed by a done event.
func (obj Output) Scale(factor int32) {
	obj.Conn().SendEvent(obj, 3, factor)
}

// Many compositors will assign user-friendly names to their outputs, show
// them to the user, allow the user to refer to an output, etc. The client
// may wish to know this name as well to offer the user similar behaviors.
//
// The name is a UTF-8 string with no convention defined for its contents.
// Each name is unique among all wl_output globals. The name is only
// guaranteed to be unique for the compositor instance.
//
// The same output name is used for all clients for a given wl_output
// global. Thus, the name can be shared across processes to refer to a
// specific wl_output global.
//
// The name is not guaranteed to be persistent across sessions, thus cannot
// be used to reliably identify an output in e.g. configuration files.
//
// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
// not assume that the name is a reflection of an underlying DRM connector,
// X11 connection, etc.
//
// The name event is sent after binding the output object. This event is
// only sent once per output object, and the name does not change over the
// lifetime of the wl_output global.
//
// Compositors may re-use the same output name if the wl_output global is
// destroyed and re-created later. Compositors should avoid re-using the
// same name if possible.
//
// The name event will be followed by a done event.
func (obj Output) Name(name string) {
	obj.Conn().SendEvent(obj, 4, name)
}

// Many compositors can produce human-readable descriptions of their
// outputs. The client may wish to know this description as well, e.g. for
// output selection purposes.
//
// The description is a UTF-8 string with no convention defined for its
// contents. The description is not guaranteed to be unique among all
// wl_output globals. Examples might include 'Foocorp 11" Display' or
// 'Virtual X11 output via :1'.
//
// The description event is sent after binding the output object and
// whenever the description changes. The description is optional, and may
// not be sent at all.
//
// The description event will be followed by a done event.
func (obj Output) Description(description string) {
	obj.Conn().SendEvent(obj, 5, description)
}

var RegionInterface = &wlproto.Interface{
	Name:    "wl_region",
	Version: 1,
	Type:    reflect.TypeOf(Region{}),
	Requests: []wlproto.Request{
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(RegionImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "add",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(RegionImplementation.Add),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "subtract",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(RegionImplementation.Subtract),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
	},
	Events: []wlproto.Event{},
}

// A region object describes an area.
//
// Region objects are used to describe the opaque and input
// regions of a surface.
type Region struct{ wlserver.Resource }

func (Region) Interface() *wlproto.Interface { return RegionInterface }

type RegionImplementation interface {
	Destroy(obj Region)
	Add(obj Region, x int32, y int32, width int32, height int32)
	Subtract(obj Region, x int32, y int32, width int32, height int32)
}

func AddRegionGlobal(dsp *wlserver.Display, version int, bind func(res Region) RegionImplementation) {
	dsp.AddGlobal(RegionInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Region)) })
}

type SubcompositorError uint32

const (
	// the to-be sub-surface is invalid
	SubcompositorErrorBadSurface SubcompositorError = 0
)

var SubcompositorInterface = &wlproto.Interface{
	Name:    "wl_subcompositor",
	Version: 1,
	Type:    reflect.TypeOf(Subcompositor{}),
	Requests: []wlproto.Request{
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(SubcompositorImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "get_subsurface",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SubcompositorImplementation.GetSubsurface),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeNewID, Aux: reflect.TypeOf(Subsurface{})},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
			},
		},
	},
	Events: []wlproto.Event{},
}

// The global interface exposing sub-surface compositing capabilities.
// A wl_surface, that has sub-surfaces associated, is called the
// parent surface. Sub-surfaces can be arbitrarily nested and create
// a tree of sub-surfaces.
//
// The root surface in a tree of sub-surfaces is the main
// surface. The main surface cannot be a sub-surface, because
// sub-surfaces must always have a parent.
//
// A main surface with its sub-surfaces forms a (compound) window.
// For window management purposes, this set of wl_surface objects is
// to be considered as a single window, and it should also behave as
// such.
//
// The aim of sub-surfaces is to offload some of the compositing work
// within a window from clients to the compositor. A prime example is
// a video player with decorations and video in separate wl_surface
// objects. This should allow the compositor to pass YUV video buffer
// processing to dedicated overlay hardware when possible.
type Subcompositor struct{ wlserver.Resource }

func (Subcompositor) Interface() *wlproto.Interface { return SubcompositorInterface }

type SubcompositorImplementation interface {
	Destroy(obj Subcompositor)
	GetSubsurface(obj Subcompositor, id Subsurface, surface Surface, parent Surface) SubsurfaceImplementation
}

func AddSubcompositorGlobal(dsp *wlserver.Display, version int, bind func(res Subcompositor) SubcompositorImplementation) {
	dsp.AddGlobal(SubcompositorInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Subcompositor)) })
}

type SubsurfaceError uint32

const (
	// wl_surface is not a sibling or the parent
	SubsurfaceErrorBadSurface SubsurfaceError = 0
)

var SubsurfaceInterface = &wlproto.Interface{
	Name:    "wl_subsurface",
	Version: 1,
	Type:    reflect.TypeOf(Subsurface{}),
	Requests: []wlproto.Request{
		{
			Name:   "destroy",
			Type:   "destructor",
			Since:  1,
			Method: reflect.ValueOf(SubsurfaceImplementation.Destroy),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "set_position",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SubsurfaceImplementation.SetPosition),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeInt},
				{Type: wlproto.ArgTypeInt},
			},
		},
		{
			Name:   "place_above",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SubsurfaceImplementation.PlaceAbove),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
			},
		},
		{
			Name:   "place_below",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SubsurfaceImplementation.PlaceBelow),
			Args: []wlproto.Arg{
				{Type: wlproto.ArgTypeObject, Aux: reflect.TypeOf(Surface{})},
			},
		},
		{
			Name:   "set_sync",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SubsurfaceImplementation.SetSync),
			Args:   []wlproto.Arg{},
		},
		{
			Name:   "set_desync",
			Type:   "",
			Since:  1,
			Method: reflect.ValueOf(SubsurfaceImplementation.SetDesync),
			Args:   []wlproto.Arg{},
		},
	},
	Events: []wlproto.Event{},
}

// An additional interface to a wl_surface object, which has been
// made a sub-surface. A sub-surface has one parent surface. A
// sub-surface's size and position are not limited to that of the parent.
// Particularly, a sub-surface is not automatically clipped to its
// parent's area.
//
// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// and the parent surface is mapped. The order of which one happens
// first is irrelevant. A sub-surface is hidden if the parent becomes
// hidden, or if a NULL wl_buffer is applied. These rules apply
// recursively through the tree of surfaces.
//
// The behaviour of a wl_surface.commit request on a sub-surface
// depends on the sub-surface's mode. The possible modes are
// synchronized and desynchronized, see methods
// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// mode caches the wl_surface state to be applied when the parent's
// state gets applied, and desynchronized mode applies the pending
// wl_surface state directly. A sub-surface is initially in the
// synchronized mode.
//
// Sub-surfaces also have another kind of state, which is managed by
// wl_subsurface requests, as opposed to wl_surface requests. This
// state includes the sub-surface position relative to the parent
// surface (wl_subsurface.set_position), and the stacking order of
// the parent and its sub-surfaces (wl_subsurface.place_above and
// .place_below). This state is applied when the parent surface's
// wl_surface state is applied, regardless of the sub-surface's mode.
// As the exception, set_sync and set_desync are effective immediately.
//
// The main surface can be thought to be always in desynchronized mode,
// since it does not have a parent in the sub-surfaces sense.
//
// Even if a sub-surface is in desynchronized mode, it will behave as
// in synchronized mode, if its parent surface behaves as in
// synchronized mode. This rule is applied recursively throughout the
// tree of surfaces. This means, that one can set a sub-surface into
// synchronized mode, and then assume that all its child and grand-child
// sub-surfaces are synchronized, too, without explicitly setting them.
//
// If the wl_surface associated with the wl_subsurface is destroyed, the
// wl_subsurface object becomes inert. Note, that destroying either object
// takes effect immediately. If you need to synchronize the removal
// of a sub-surface to the parent surface update, unmap the sub-surface
// first by attaching a NULL wl_buffer, update parent, and then destroy
// the sub-surface.
//
// If the parent wl_surface object is destroyed, the sub-surface is
// unmapped.
type Subsurface struct{ wlserver.Resource }

func (Subsurface) Interface() *wlproto.Interface { return SubsurfaceInterface }

type SubsurfaceImplementation interface {
	Destroy(obj Subsurface)
	SetPosition(obj Subsurface, x int32, y int32)
	PlaceAbove(obj Subsurface, sibling Surface)
	PlaceBelow(obj Subsurface, sibling Surface)
	SetSync(obj Subsurface)
	SetDesync(obj Subsurface)
}

func AddSubsurfaceGlobal(dsp *wlserver.Display, version int, bind func(res Subsurface) SubsurfaceImplementation) {
	dsp.AddGlobal(SubsurfaceInterface, version, func(res wlserver.Object) wlserver.ResourceImplementation { return bind(res.(Subsurface)) })
}
