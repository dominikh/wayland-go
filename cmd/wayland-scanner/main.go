package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/shurcooL/graphql/ident"
)

type elProtocol struct {
	Name string `xml:"name,attr"`

	Copyright   elCopyright   `xml:"copyright"`
	Description elDescription `xml:"description"`
	Interfaces  []elInterface `xml:"interface"`
}

type elCopyright struct {
	Text string `xml:",cdata"`
}

type elInterface struct {
	Name    string `xml:"name,attr"`
	Version string `xml:"version,attr"`

	Description elDescription `xml:"description"`
	Requests    []elRequest   `xml:"request"`
	Events      []elEvent     `xml:"event"`
	Enums       []elEnum      `xml:"enum"`
}

type elRequest struct {
	Name  string `xml:"name,attr"`
	Type  string `xml:"type,attr"`
	Since string `xml:"since,attr"`

	Description elDescription `xml:"description"`
	Args        []elArg       `xml:"arg"`
}

type elEvent struct {
	Name  string `xml:"name,attr"`
	Since string `xml:"since,attr"`

	Description elDescription `xml:"description"`
	Args        []elArg       `xml:"arg"`
}

type elEnum struct {
	Name     string `xml:"name,attr"`
	Since    string `xml:"since,attr"`
	Bitfield string `xml:"bitfield,attr"`

	Description elDescription `xml:"description"`
	Entries     []elEntry     `xml:"entry"`
}

type elEntry struct {
	Name    string `xml:"name,attr"`
	Value   string `xml:"value,attr"`
	Summary string `xml:"summary,attr"`
	Since   string `xml:"since,attr"`

	Description elDescription `xml:"description"`
}

type elArg struct {
	Name      string `xml:"name,attr"`
	Type      string `xml:"type,attr"`
	Summary   string `xml:"summary,attr"`
	Interface string `xml:"interface,attr"`
	AllowNull string `xml:"allow-null,attr"`
	Enum      string `xml:"enum,attr"`

	Description elDescription `xml:"description"`
}

type elDescription struct {
	Summary string `xml:"summary,attr"`

	Text string `xml:",cdata"`
}

func typeName(name string) string {
	name = strings.TrimPrefix(name, "wl_")
	if len(name) == 0 {
		// XXX
	}
	return exportedGoIdentifier(name)
}

func eventsTypeName(iface elInterface) string {
	return fmt.Sprintf("%sEvents", typeName(iface.Name))
}

// XXX check for reserved names

func exportedGoIdentifier(name string) string {
	name = strings.TrimSuffix(name, "_")
	return ident.Name(strings.Split(name, "_")).ToMixedCaps()
}

func goIdentifier(name string) string {
	name = strings.TrimSuffix(name, "_")
	name = ident.Name(strings.Split(name, "_")).ToLowerCamelCase()
	return mapReserved(name)
}

func mapReserved(name string) string {
	switch name {
	case "interface":
		return "interface_"
	default:
		return name
	}
}

func wlprotoInterfaceName(iface elInterface) string {
	name := strings.TrimPrefix(iface.Name, "wl_")
	if len(name) == 0 {
		// XXX
	}
	return goIdentifier(name) + "Interface"
}

func wlprotoArg(arg elArg) string {
	var typ string
	switch arg.Type {
	case "int":
		typ = "ArgTypeInt"
	case "uint":
		typ = "ArgTypeUint"
	case "fixed":
		typ = "ArgTypeFixed"
	case "string":
		typ = "ArgTypeString"
	case "object":
		typ = "ArgTypeObject"
	case "new_id":
		typ = "ArgTypeNewID"
	case "array":
		typ = "ArgTypeArray"
	case "fd":
		typ = "ArgTypeFd"
	default:
		panic("XXX")
	}
	if arg.Interface == "" {
		return fmt.Sprintf("{Type: wlproto.%s}", typ)
	} else {
		return fmt.Sprintf("{Type: wlproto.%s, Aux: reflect.TypeOf((*%s)(nil))}", typ, typeName(arg.Interface))
	}
}

func goTypeFromWlType(typ string, iface string) string {
	switch typ {
	case "int":
		return "int32"
	case "uint":
		return "uint32"
	case "fixed":
		return "wlclient.Fixed"
	case "string":
		return "string"
	case "object":
		if iface != "" {
			return "*" + typeName(iface)
		} else {
			return "wlclient.Object"
		}
	case "new_id":
		if iface != "" {
			return "*" + typeName(iface)
		} else {
			return "wlclient.Object"
		}
	case "array":
		return "[]byte"
	case "fd":
		return "uintptr"
	default:
		return "UNKNOWN_TYPE_" + typ
	}
}

func docString(docs elDescription) string {
	text := docs.Text
	if text == "" {
		text = docs.Summary
		if text == "" {
			return ""
		}
	}

	text = strings.TrimSpace(text)
	lines := strings.Split(text, "\n")
	for i, line := range lines {
		lines[i] = "// " + strings.TrimSpace(line)
	}
	return strings.Join(lines, "\n")
}

func enumEntryDocString(entry elEntry) string {
	if entry.Description.Text != "" || entry.Description.Summary != "" {
		return docString(entry.Description)
	}
	if entry.Summary == "" {
		return ""
	}
	return "// " + entry.Summary
}

func printSpecs(w io.Writer, state tmplState) {
	printPackage := func() {
		fmt.Fprintln(w, "// Code generated by wayland-scanner; DO NOT EDIT.")
		fmt.Fprintln(w, "//")
		fmt.Fprintln(w, "// Package pkg contains generated definitions of Wayland protocols.")
		fmt.Fprintln(w, "//")
		fmt.Fprintln(w, "// It was generated from the following files:")

		for _, f := range state.InputFiles {
			fmt.Fprintf(w, "// \t- %s\n", f)
		}

		fmt.Fprintln(w, "package pkg")

	}

	printImports := func() {
		fmt.Fprintln(w, "import (")
		for _, imp := range state.Imports {
			fmt.Fprintf(w, "\t%q\n", imp)
		}
		fmt.Fprintln(w, ")")
	}

	printMaps := func() {
		fmt.Fprintln(w, "var Interfaces = map[string]*wlproto.Interface{")
		for _, spec := range state.Specs {
			for _, iface := range spec.Interfaces {
				fmt.Fprintf(w, "\t%q: %s,\n", iface.Name, wlprotoInterfaceName(iface))
			}
		}
		fmt.Fprint(w, "}\n\n")

		fmt.Fprintln(w, "var Requests = map[string]*wlproto.Request{")
		for _, spec := range state.Specs {
			for _, iface := range spec.Interfaces {
				for ireq, req := range iface.Requests {
					fmt.Fprintf(w, "\t\"%s_%s\": &%s.Requests[%d],\n", iface.Name, req.Name, wlprotoInterfaceName(iface), ireq)
				}
			}
		}
		fmt.Fprint(w, "}\n\n")

		fmt.Fprintln(w, "var Events = map[string]*wlproto.Event{")
		for _, spec := range state.Specs {
			for _, iface := range spec.Interfaces {
				for iev, ev := range iface.Events {
					fmt.Fprintf(w, "\t\"%s_%s\": &%s.Events[%d],\n", iface.Name, ev.Name, wlprotoInterfaceName(iface), iev)
				}
			}
		}
		fmt.Fprintln(w, "}")
	}

	printInterface := func(iface elInterface) {
		printEnums := func() {
			for _, enum := range iface.Enums {
				fmt.Fprintln(w, docString(enum.Description))
				fmt.Fprintln(w, "const (")
				for _, entry := range enum.Entries {
					fmt.Fprintf(w, "\t%s\n", enumEntryDocString(entry))
					fmt.Fprintf(w, "\t%s%s%s = %s\n", typeName(iface.Name), exportedGoIdentifier(enum.Name), exportedGoIdentifier(entry.Name), entry.Value)
				}
				fmt.Fprintln(w, ")")
			}
		}

		printInterfaceVar := func() {
			fmt.Fprintf(w, "var %s = &wlproto.Interface{\n", wlprotoInterfaceName(iface))
			fmt.Fprintf(w, "\tName: %q,\n", iface.Name)
			fmt.Fprintf(w, "\tVersion: %s,\n", iface.Version)

			fmt.Fprintln(w, "\tRequests: []wlproto.Request{")
			for _, req := range iface.Requests {
				if req.Since == "" {
					req.Since = "1"
				}
				fmt.Fprintln(w, "\t\t{")
				fmt.Fprintf(w, "\t\t\tName: %q,\n", req.Name)
				fmt.Fprintf(w, "\t\t\tType: %q,\n", req.Type)
				fmt.Fprintf(w, "\t\t\tSince: %s,\n", req.Since)

				fmt.Fprintln(w, "\t\t\tArgs: []wlproto.Arg{")
				for _, arg := range req.Args {
					fmt.Fprintf(w, "\t\t\t\t%s,\n", wlprotoArg(arg))
				}
				fmt.Fprintln(w, "\t\t\t},")

				fmt.Fprintln(w, "\t\t},")
			}
			fmt.Fprintln(w, "\t},")

			fmt.Fprintln(w, "\tEvents: []wlproto.Event{")
			for _, ev := range iface.Events {
				if ev.Since == "" {
					ev.Since = "1"
				}
				fmt.Fprintln(w, "\t\t{")
				fmt.Fprintf(w, "\t\t\tName: %q,\n", ev.Name)
				fmt.Fprintf(w, "\t\t\tSince: %s,\n", ev.Since)

				fmt.Fprintln(w, "\t\t\tArgs: []wlproto.Arg{")
				for _, arg := range ev.Args {
					fmt.Fprintf(w, "\t\t\t\t%s,\n", wlprotoArg(arg))
				}
				fmt.Fprintln(w, "\t\t\t},")

				fmt.Fprintln(w, "\t\t},")
			}
			fmt.Fprintln(w, "\t},")

			fmt.Fprintln(w, "}")
		}

		printInterfaceEventsType := func() {
			fmt.Fprintf(w, "type %s struct {\n", eventsTypeName(iface))
			for _, ev := range iface.Events {
				fmt.Fprintf(w, "\t%s func(obj *%s,", exportedGoIdentifier(ev.Name), typeName(iface.Name))
				for _, arg := range ev.Args {
					fmt.Fprintf(w, "%s %s,", goIdentifier(arg.Name), goTypeFromWlType(arg.Type, arg.Interface))
				}
				fmt.Fprintln(w, ")")
			}
			fmt.Fprint(w, "}\n\n")
		}

		printInterfaceType := func() {
			fmt.Fprintln(w, docString(iface.Description))
			fmt.Fprintf(w, "type %s struct { wlclient.Proxy }\n\n", typeName(iface.Name))

			// basic methods
			fmt.Fprintf(w, "func (*%s) Interface() *wlproto.Interface { return %s }\n\n", typeName(iface.Name), wlprotoInterfaceName(iface))

			fmt.Fprintf(w, "func (obj *%[1]s) WithQueue(queue *wlclient.EventQueue) *%[1]s {\n", typeName(iface.Name))
			fmt.Fprintf(w, "\twobj := &%s{}\n", typeName(iface.Name))
			fmt.Fprintf(w, "\tobj.Conn().NewWrapper(obj, wobj, queue)\n")
			fmt.Fprintf(w, "\treturn wobj\n")
			fmt.Fprintf(w, "}\n\n")

			printInterfaceEventsType()
			fmt.Fprintf(w, "func (obj *%s) AddListener(listeners %s) {\n", typeName(iface.Name), eventsTypeName(iface))
			fmt.Fprint(w, "\tobj.Proxy.SetListeners(")
			for _, ev := range iface.Events {
				fmt.Fprintf(w, "listeners.%s,", exportedGoIdentifier(ev.Name))
			}
			fmt.Fprintln(w, ")")
			fmt.Fprint(w, "}\n\n")
		}

		printRequest := func(ireq int, req elRequest) {
			var ctor elArg
			fmt.Fprintln(w, docString(req.Description))
			fmt.Fprintf(w, "func (obj *%s) %s(", typeName(iface.Name), exportedGoIdentifier(req.Name))
			for _, arg := range req.Args {
				if arg.Type == "new_id" {
					ctor = arg
				}
				if arg.Type != "new_id" {
					fmt.Fprintf(w, "%s %s,", goIdentifier(arg.Name), goTypeFromWlType(arg.Type, arg.Interface))
				} else if arg.Interface == "" {
					fmt.Fprintf(w, "%s %s, version uint32,", goIdentifier(arg.Name), goTypeFromWlType(arg.Type, arg.Interface))
				}
			}
			fmt.Fprint(w, ")")
			if ctor.Interface != "" {
				fmt.Fprintf(w, "*%s", typeName(ctor.Interface))
			}

			fmt.Fprintln(w, "{")
			if ctor.Interface != "" {
				fmt.Fprintf(w, "\t_ret := &%s{}\n", typeName(ctor.Interface))
				fmt.Fprintln(w, "\tobj.Conn().NewProxy(0, _ret, obj.Queue())")
			}

			fmt.Fprintf(w, "\tobj.Conn().SendRequest(obj, %d, ", ireq)
			for _, arg := range req.Args {
				if arg.Type == "new_id" {
					if ctor.Interface == "" {
						fmt.Fprintf(w, "%[1]s.Interface().Name, version, %[1]s,", goIdentifier(ctor.Name))
					} else {
						fmt.Fprint(w, "_ret,")
					}
				} else {
					fmt.Fprintf(w, "%s,", goIdentifier(arg.Name))
				}
			}
			fmt.Fprintln(w, ")")

			if req.Type == "destructor" {
				fmt.Fprintln(w, "\tobj.Conn().Destroy(obj)")
			}

			if ctor.Interface != "" {
				fmt.Fprintln(w, "\treturn _ret")
			}

			fmt.Fprint(w, "}\n\n")
		}

		printEnums()
		printInterfaceVar()
		printInterfaceType()

		hasDestroy := false
		for ireq, req := range iface.Requests {
			if req.Name == "destroy" {
				hasDestroy = true
			}
			printRequest(ireq, req)
		}
		if !hasDestroy {
			fmt.Fprintf(w, "func (obj *%s) Destroy() { obj.Conn().Destroy(obj) }\n\n", typeName(iface.Name))
		}
	}

	printPackage()
	printImports()
	printMaps()
	for _, spec := range state.Specs {
		for _, iface := range spec.Interfaces {
			printInterface(iface)
		}

		if spec.Name == "wayland" {
			fmt.Fprintln(w, "func GetDisplay(conn *wlclient.Conn) *Display { _ret := &Display{}; conn.NewProxy(1, _ret, nil); return _ret }")
		}
	}
}

type tmplState struct {
	InputFiles []string
	Imports    []string
	Specs      []elProtocol
}

func main() {
	var specs []elProtocol
	for _, arg := range os.Args[1:] {
		f, err := os.OpenFile(arg, os.O_RDONLY, 0)
		if err != nil {
			log.Fatal(err)
		}

		var spec elProtocol
		dec := xml.NewDecoder(f)
		if err := dec.Decode(&spec); err != nil {
			log.Fatal(err)
		}
		specs = append(specs, spec)
		f.Close()
	}

	var state tmplState
	for _, arg := range os.Args[1:] {
		state.InputFiles = append(state.InputFiles, filepath.Base(arg))
	}
	state.Imports = []string{
		"reflect",
		"honnef.co/go/wayland/wlclient",
		"honnef.co/go/wayland/wlproto",
	}
	state.Specs = specs

	var buf bytes.Buffer
	printSpecs(&buf, state)
	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.Stdout.Write(out)
}
