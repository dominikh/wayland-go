// Package wlclient provides a low-level client and runtime for the
// Wayland protocol.
//
// This package provides the interfaces and low-level functions for
// establishing Wayland client connections, as well as runtime support
// for code-generated protocol implementations.
//
// It is loosely based on libwayland-client, but designed around Go's
// type system.
//
//
// The Proxy type
//
// Similar to libwayland-client, we rely heavily on the concept of a
// proxy. In the Wayland protocol, the client can associate numeric
// IDs with server-side resources. The Proxy type encapsulates this
// ID, and provides all the internal state necessary for using
// requests and receiving events.
//
// Code generated by our wayland-scanner will generate wrapper types
// for Wayland interfaces (such as wl_buffer) that provide a strongly
// typed abstraction on top of proxies. Code that operates on
// arbitrary objects will accept the Object interface, as opposed to
// instances of *Proxy.
//
//
// Event loop
//
// TODO explain how events work
//
//
// Code generation
//
// TODO explain code generation, mega-packages, and converting types
// between packages.
package wlclient

// Object deletion and races
//
// Wayland is an asynchronous protocol. The client may decide to
// delete an object while the server is still sending events for it.
// When we receive an event for a object we don't know about, we drop
// the event.
//
// Some objects have methods that receive file descriptors and we need
// to consume these fds even for events we're dropping. Thus, when
// deleting such an object, we create a "zombie" that contains just
// enough information to consume fds. It is assumed that any such
// objects have a server-side destructor, so that we will eventually
// receive a delete_id event and can remove the zombie.
//
// Objects can also be used as arguments in events, where the same
// race can apply. Thus, when an argument fails to resolve to an
// object, we set the argument to nil. This is arguably gnarly,
// because every event handler will have to check that its arguments
// aren't nil.
//
// Some objects get destroyed by the server, not the client (most
// famously wl_callback), so we mustn't create zombies if the object
// has already been deleted, i.e. if our call to Destroy happens after
// we have processed the server's Destroy.

import (
	"encoding/binary"
	"net"
	"reflect"
	"sync"
	"syscall"
	"unsafe"

	"honnef.co/go/wayland/wlproto"
	"honnef.co/go/wayland/wlshared"
)

type Object interface {
	wlshared.Object
	Conn() *Conn
	Interface() *wlproto.Interface
	GetProxy() *Proxy
	Queue() *EventQueue
	EventHandlers() []interface{}
}

var byteOrder binary.ByteOrder

func init() {
	var x uint32 = 0x01020304
	if *(*byte)(unsafe.Pointer(&x)) == 0x01 {
		byteOrder = binary.BigEndian
	} else {
		byteOrder = binary.LittleEndian
	}
}

// Proxy encapsulates all the internal state of client-side objects.
//
// Conceptually, a proxy is an ID that is associated with some
// server-side resource. Concretely, a proxy contains all state
// necessary for requests and events to function correctly.
//
// Code generation will create strongly typed wrapper structs for
// Proxy, and user-level code will primarily interact with these
// wrapper types.
type Proxy struct {
	id            wlshared.ObjectID
	conn          *Conn
	eventHandlers []interface{}
	queue         *EventQueue
}

// GetProxy returns p. It helps objects implement the Object interface.
func (p *Proxy) GetProxy() *Proxy { return p }

// ID returns the object's ID.
func (p *Proxy) ID() wlshared.ObjectID { return p.id }

// Conn returns the connection the object belongs to.
func (p *Proxy) Conn() *Conn { return p.conn }

// Queue returns the object's event queue.
func (p *Proxy) Queue() *EventQueue { return p.queue }

func (p *Proxy) EventHandlers() []interface{} { return p.eventHandlers }

// SetListeners sets the event callbacks associated with the proxy.
//
// This is a function provided for use by generated code.
// User-level code should use generated AddListener methods instead.
func (p *Proxy) SetListeners(listeners ...interface{}) {
	copy(p.eventHandlers, listeners)
}

type object struct {
	kind uint8
	fds  []int
	obj  Object
}

const (
	objectKindZombie = iota + 1
)

type EventQueue struct {
	// signals the availability of events
	ch chan struct{}

	mu     sync.Mutex
	events []Event
}

func NewEventQueue() *EventQueue {
	return &EventQueue{
		ch: make(chan struct{}, 1),
	}
}

func (q *EventQueue) Push(ev Event) {
	q.mu.Lock()
	defer q.mu.Unlock()
	q.events = append(q.events, ev)
	select {
	case q.ch <- struct{}{}:
	default:
	}
}

func (q *EventQueue) Dispatch() {
	<-q.ch
	q.mu.Lock()
	defer q.mu.Unlock()
	for _, ev := range q.events {
		handlers := ev.Obj.EventHandlers()
		cb := handlers[ev.Ev]
		if cb != nil {
			args := []reflect.Value{reflect.ValueOf(ev.Obj)}
			args = append(args, ev.Args...)
			reflect.ValueOf(cb).Call(args)
		}
	}
	q.events = q.events[:0]
}

type Event struct {
	Obj  Object
	Ev   int
	Args []reflect.Value
}

type Conn struct {
	debug        bool
	defaultQueue *EventQueue

	mu      sync.Mutex
	rw      *net.UnixConn
	objects map[wlshared.ObjectID]object
	maxID   wlshared.ObjectID
	sendBuf []byte

	data []byte
	fds  []uintptr
}

func NewConn(rw *net.UnixConn) *Conn {
	c := &Conn{
		rw:           rw,
		objects:      map[wlshared.ObjectID]object{},
		debug:        true,
		defaultQueue: NewEventQueue(),
		maxID:        1,
	}
	go c.readLoop()
	return c
}

// NewWrapper initializes the proxy in wrapper with a copy of obj's
// proxy, but with a different queue.
//
// This is a function provided for use by generated code.
// User-level code should use generated WithQueue methods instead.
func (c *Conn) NewWrapper(obj Object, wrapper Object, queue *EventQueue) {
	p := obj.GetProxy()
	*wrapper.GetProxy() = Proxy{
		id:    p.ID(),
		conn:  c,
		queue: queue,
	}
}

// NewProxy initialized the proxy in obj with the given id and queue.
// If queue is nil, the connection's default queue will be used.
func (c *Conn) NewProxy(id wlshared.ObjectID, obj Object, queue *EventQueue) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if queue == nil {
		queue = c.defaultQueue
	}
	p := obj.GetProxy()
	*p = Proxy{
		id:            id,
		conn:          c,
		eventHandlers: make([]interface{}, len(obj.Interface().Events)),
		queue:         queue,
	}
	if id != 0 {
		c.objects[id] = object{obj: obj}
	}
}

// Destroy destroys obj's proxy.
//
// This is a function provided for use by generated code.
// User-level code should use generated destructors instead.
func (c *Conn) Destroy(obj Object) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.objects, obj.ID())
}

func (c *Conn) SendDestructor(obj Object, request int, args ...interface{}) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.sendRequest(obj, request, args...)

	if _, ok := c.objects[obj.ID()]; !ok {
		// the server has already destroyed the object before we
		// decided to destroy it
		return
	}

	// OPT(dh): cache this computation
	var fds []int
	for i, ev := range obj.Interface().Events {
		var nfds int
		for _, arg := range ev.Args {
			if arg.Type == wlproto.ArgTypeFd {
				nfds++
			}
		}
		if nfds > 0 {
			if fds == nil {
				fds = make([]int, len(obj.Interface().Events))
				fds[i] = nfds
			}
		}
	}

	c.objects[obj.ID()] = object{
		kind: objectKindZombie,
		fds:  fds,
		obj:  obj,
	}
}

func (c *Conn) SendRequest(source Object, request int, args ...interface{}) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.sendRequest(source, request, args...)
}

func (c *Conn) sendRequest(source Object, request int, args ...interface{}) {
	for _, arg := range args {
		if arg, ok := arg.(Object); ok {
			id := arg.ID()
			if id == 0 {
				c.maxID++
				id = c.maxID

				p := arg.GetProxy()
				if p.conn == nil {
					*p = Proxy{
						id:            id,
						conn:          c,
						eventHandlers: make([]interface{}, len(arg.Interface().Events)),
						queue:         c.defaultQueue,
					}
				} else {
					p.id = id
				}
				c.objects[id] = object{obj: arg}
			}
		}
	}

	buf := c.sendBuf[:0]
	var oob []byte
	buf, oob = wlshared.EncodeRequest(buf, source.ID(), request, args)

	c.rw.WriteMsgUnix(buf, oob, nil)

	c.sendBuf = buf[:0]
}

func (c *Conn) read() {
	b := make([]byte, 1<<16)
	// XXX can there be more than one SCM per message?
	// XXX in general, be more robust in handling SCM
	oob := make([]byte, 24)
	n, oobn, _, _, err := c.rw.ReadMsgUnix(b, oob)
	if err != nil {
		panic(err)
	}
	c.data = append(c.data, b[:n]...)
	if oobn == 24 {
		scm, err := syscall.ParseSocketControlMessage(oob[:oobn])
		if err != nil {
			panic(err)
		}
		fds, err := syscall.ParseUnixRights(&scm[0])
		if err != nil {
			panic(err)
		}
		c.fds = append(c.fds, uintptr(fds[0]))
	}
}

func (c *Conn) readAtLeast(n int) {
	for len(c.data) < n {
		c.read()
	}
}

func (c *Conn) readLoop() {
	for {
		c.readAtLeast(8)
		sender := wlshared.ObjectID(byteOrder.Uint32(c.data[0:4]))
		h := byteOrder.Uint32(c.data[4:8])
		size := (h & 0xFFFF0000) >> 16
		if size < 8 {
			// XXX invalid size
		}
		size -= 8
		// XXX guard against invalid opcodes
		opcode := h & 0x0000FFFF
		c.data = c.data[8:]
		c.readAtLeast(int(size))

		d := c.data[:size]
		c.data = c.data[size:]

		c.mu.Lock()
		objw, ok := c.objects[sender]
		if !ok {
			// we don't know the object, we don't even have a zombie
			// for it -> ignore the message.
			c.mu.Unlock()
			continue
		}
		if objw.kind == objectKindZombie {
			// this object has been deleted, see if we need to consume
			// fds.
			if fds := objw.fds[opcode]; fds > 0 {
				copy(c.fds, c.fds[fds:])
				c.fds = c.fds[:len(c.fds)-fds]
			}
			c.mu.Unlock()
			continue
		}
		obj := objw.obj
		c.mu.Unlock()
		off := 0
		sig := obj.Interface().Events[opcode].Args
		args := make([]reflect.Value, len(sig))
		for i, arg := range sig {
			newOff, argv := wlshared.ParseArgument(arg, d, off)
			off = newOff

			switch arg.Type {
			case wlproto.ArgTypeObject:
				c.mu.Lock()
				// XXX guard against invalid object id
				args[i] = reflect.ValueOf(c.objects[argv.(wlshared.ObjectID)])
				c.mu.Unlock()
			case wlproto.ArgTypeFd:
				fd := c.fds[0]
				copy(c.fds, c.fds[1:])
				c.fds = c.fds[:len(c.fds)-1]
				args[i] = reflect.ValueOf(uintptr(fd))
			case wlproto.ArgTypeNewID:
				// XXX verify that the new ID isn't already in use
				// XXX verify that the new ID is in the server's ID space
				v := reflect.New(arg.Aux.Elem()).Interface().(Object)
				c.NewProxy(argv.(wlshared.ObjectID), v, obj.Queue())
				c.mu.Lock()
				c.objects[argv.(wlshared.ObjectID)] = object{obj: v}
				c.mu.Unlock()
			default:
				args[i] = reflect.ValueOf(argv)
			}
		}

		if sender == 1 && opcode == 1 {
			// Special case for the delete_id event on wl_display.
			// Primarily to clean up zombies, but this event may also
			// fire without us having called a server-side destructor.
			// For example, wl_callback gets destroyed by the server
			// once it has fired.
			c.mu.Lock()
			id := wlshared.ObjectID(args[0].Uint())
			delete(c.objects, id)
			c.mu.Unlock()
		}
		obj.GetProxy().queue.Push(Event{obj, int(opcode), args})
	}
}
