// Package wlclient provides a low-level client and runtime for the
// Wayland protocol.
//
// This package provides the interfaces and low-level functions for
// establishing Wayland client connections, as well as runtime support
// for code-generated protocol implementations.
//
// It is loosely based on libwayland-client, but designed around Go's
// type system.
//
//
// The Proxy type
//
// Similar to libwayland-client, we rely heavily on the concept of a
// proxy. In the Wayland protocol, the client can associate numeric
// IDs with server-side resources. The Proxy type encapsulates this
// ID, and provides all the internal state necessary for using
// requests and receiving events.
//
// Code generated by our wayland-scanner will generate wrapper types
// for Wayland interfaces (such as wl_buffer) that provide a strongly
// typed abstraction on top of proxies. Code that operates on
// arbitrary objects will accept the Object interface, as opposed to
// instances of *Proxy.
//
//
// Event loop
//
// TODO explain how events work
//
//
// Code generation
//
// TODO explain code generation, mega-packages, and converting types
// between packages.
package wlclient

// Object deletion and races
//
// Wayland is an asynchronous protocol. The client may decide to
// delete an object while the server is still sending events for it.
// When we receive an event for a object we don't know about, we drop
// the event.
//
// Some objects have methods that receive file descriptors and we need
// to consume these fds even for events we're dropping. Thus, when
// deleting such an object, we create a "zombie" that contains just
// enough information to consume fds. It is assumed that any such
// objects have a server-side destructor, so that we will eventually
// receive a delete_id event and can remove the zombie.
//
// Objects can also be used as arguments in events, where the same
// race can apply. Thus, when an argument fails to resolve to an
// object, we set the argument to nil. This is arguably gnarly,
// because every event handler will have to check that its arguments
// aren't nil. I believe even libwayland-client gets this partially
// wrong, because it only allows missing objects when zombies exist,
// otherwise an EINVAL is produced.
//
// Some objects get destroyed by the server, not the client (most
// famously wl_callback), so we mustn't create zombies if the object
// has already been deleted, i.e. if our call to Destroy happens after
// we have processed the server's Destroy.

import (
	"encoding/binary"
	"fmt"
	"net"
	"reflect"
	"sync"
	"syscall"
	"unsafe"

	"honnef.co/go/wayland/wlproto"
)

type Fixed uint32

func (f Fixed) Float64() float64 {
	panic("XXX")
}

func FromFloat64(f float64) Fixed {
	panic("XXX")
}

type ObjectID uint32
type NewID uint32

type Object interface {
	ID() ObjectID
	Conn() *Conn
	Interface() *wlproto.Interface
	GetProxy() *Proxy
	Queue() *EventQueue
}

var byteOrder binary.ByteOrder

func init() {
	var x uint32 = 0x01020304
	if *(*byte)(unsafe.Pointer(&x)) == 0x01 {
		byteOrder = binary.BigEndian
	} else {
		byteOrder = binary.LittleEndian
	}
}

// Proxy encapsulates all the internal state of client-side objects.
//
// Conceptually, a proxy is an ID that is associated with some
// server-side resource. Concretely, a proxy contains all state
// necessary for requests and events to function correctly.
//
// Code generation will create strongly typed wrapper structs for
// Proxy, and user-level code will primarily interact with these
// wrapper types.
type Proxy struct {
	id            ObjectID
	conn          *Conn
	eventHandlers []interface{}
	queue         *EventQueue
}

// GetProxy returns p. It helps objects implement the Object interface.
func (p *Proxy) GetProxy() *Proxy { return p }

// ID returns the object's ID.
func (p *Proxy) ID() ObjectID { return p.id }

// Conn returns the connection the object belongs to.
func (p *Proxy) Conn() *Conn { return p.conn }

// Queue returns the object's event queue.
func (p *Proxy) Queue() *EventQueue { return p.queue }

// SetListeners sets the event callbacks associated with the proxy.
//
// This is a function provided for use by generated code.
// User-level code should use generated AddListener methods instead.
func (p *Proxy) SetListeners(listeners ...interface{}) {
	copy(p.eventHandlers, listeners)
}

type event struct {
	obj  Object
	ev   int
	args []reflect.Value
}

// A zombie carries just enough state about deleted objects to
// correctly discard events addressed to them.
type zombie struct {
	// the number of file descriptors, indexed by event index.
	fds []int
}

type Conn struct {
	debug        bool
	defaultQueue *EventQueue

	mu      sync.Mutex
	rw      *net.UnixConn
	objects map[ObjectID]Object
	zombies map[ObjectID]zombie
	maxID   ObjectID
	sendBuf []byte

	data []byte
	fds  []uintptr
}

func NewConn(rw *net.UnixConn) *Conn {
	c := &Conn{
		rw:           rw,
		objects:      map[ObjectID]Object{},
		debug:        true,
		defaultQueue: NewEventQueue(),
		maxID:        1,
	}
	go c.readLoop()
	return c
}

// NewWrapper initializes the proxy in wrapper with a copy of obj's
// proxy, but with a different queue.
//
// This is a function provided for use by generated code.
// User-level code should use generated WithQueue methods instead.
func (c *Conn) NewWrapper(obj Object, wrapper Object, queue *EventQueue) {
	p := obj.GetProxy()
	*wrapper.GetProxy() = Proxy{
		id:    p.ID(),
		conn:  c,
		queue: queue,
	}
}

// NewProxy initialized the proxy in obj with the given id and queue.
// If queue is nil, the connection's default queue will be used.
func (c *Conn) NewProxy(id ObjectID, obj Object, queue *EventQueue) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if queue == nil {
		queue = c.defaultQueue
	}
	p := obj.GetProxy()
	*p = Proxy{
		id:            id,
		conn:          c,
		eventHandlers: make([]interface{}, len(obj.Interface().Events)),
		queue:         queue,
	}
	if id != 0 {
		c.objects[id] = obj
	}
}

// Destroy destroys obj's proxy.
//
// This is a function provided for use by generated code.
// User-level code should use generated destructors instead.
func (c *Conn) Destroy(obj Object) {
	// OPT(dh): cache this computation
	var z zombie
	for i, ev := range obj.Interface().Events {
		var fds int
		for _, arg := range ev.Args {
			if arg.Type == wlproto.ArgTypeFd {
				fds++
			}
		}
		if fds > 0 {
			if z.fds == nil {
				z.fds = make([]int, len(obj.Interface().Events))
				z.fds[i] = fds
			}
		}
	}

	c.mu.Lock()
	if z.fds != nil {
		_, ok := c.objects[obj.ID()]
		if ok {
			c.zombies[obj.ID()] = z
		}
	}
	delete(c.objects, obj.ID())
	c.mu.Unlock()
}

func (c *Conn) SendRequest(source Object, request int, args ...interface{}) {
	c.mu.Lock()
	defer c.mu.Unlock()

	buf := c.sendBuf[:0]
	buf = append(buf, 0, 0, 0, 0, 0, 0, 0, 0)
	var scratch [4]byte

	var fds []int
	for _, arg := range args {
		switch arg := arg.(type) {
		case int32:
			byteOrder.PutUint32(scratch[:], uint32(arg))
			buf = append(buf, scratch[:]...)
		case uint32:
			byteOrder.PutUint32(scratch[:], arg)
			buf = append(buf, scratch[:]...)
		case Fixed:
			byteOrder.PutUint32(scratch[:], uint32(arg))
			buf = append(buf, scratch[:]...)
		case string:
			byteOrder.PutUint32(scratch[:], uint32(len(arg)+1))
			buf = append(buf, scratch[:]...)
			buf = append(buf, arg...)
			buf = append(buf, 0)
			m := len(arg) + 1
			n := (m + 3) & ^3
			for i := n - m; i > 0; i-- {
				buf = append(buf, 0)
			}
			// XXX array
		case uintptr:
			fds = append(fds, int(arg))
		case Object:
			id := arg.ID()
			if id == 0 {
				c.maxID++
				id = c.maxID

				p := arg.GetProxy()
				if p.conn == nil {
					*p = Proxy{
						id:            id,
						conn:          c,
						eventHandlers: make([]interface{}, len(arg.Interface().Events)),
						queue:         c.defaultQueue,
					}
				} else {
					p.id = id
				}
				c.objects[id] = arg
			}
			byteOrder.PutUint32(scratch[:], uint32(id))
			buf = append(buf, scratch[:]...)
		default:
			panic(fmt.Sprintf("internal error: unhandled type %T", arg))
		}
	}
	byteOrder.PutUint32(buf[0:4], uint32(source.ID()))
	byteOrder.PutUint16(buf[4:6], uint16(request))
	byteOrder.PutUint16(buf[6:8], uint16(len(buf)))

	var oob []byte
	if len(fds) > 0 {
		// OPT(dh): we send file descriptors so rarely that allocating
		// here isn't an issue.
		oob = syscall.UnixRights(fds...)
	}
	c.rw.WriteMsgUnix(buf, oob, nil)

	c.sendBuf = buf[:0]
}

func (c *Conn) read() {
	b := make([]byte, 1<<16)
	// XXX can there be more than one SCM per message?
	// XXX in general, be more robust in handling SCM
	oob := make([]byte, 24)
	n, oobn, _, _, err := c.rw.ReadMsgUnix(b, oob)
	if err != nil {
		panic(err)
	}
	c.data = append(c.data, b[:n]...)
	if oobn == 24 {
		scm, err := syscall.ParseSocketControlMessage(oob[:oobn])
		if err != nil {
			panic(err)
		}
		fds, err := syscall.ParseUnixRights(&scm[0])
		if err != nil {
			panic(err)
		}
		c.fds = append(c.fds, uintptr(fds[0]))
	}
}

func (c *Conn) readAtLeast(n int) {
	for len(c.data) < n {
		c.read()
	}
}

func (c *Conn) readLoop() {
	for {
		c.readAtLeast(8)
		sender := ObjectID(byteOrder.Uint32(c.data[0:4]))
		h := byteOrder.Uint32(c.data[4:8])
		size := (h & 0xFFFF0000) >> 16
		if size < 8 {
			// XXX invalid size
		}
		size -= 8
		opcode := h & 0x0000FFFF
		c.data = c.data[8:]
		c.readAtLeast(int(size))

		d := c.data[:size]
		c.data = c.data[size:]

		c.mu.Lock()
		obj, ok := c.objects[sender]
		if !ok {
			// unknown object ID. it's possible that the server sent
			// us an event while we were destroying the object.
			z, ok := c.zombies[sender]
			if ok {
				if fds := z.fds[opcode]; fds > 0 {
					copy(c.fds, c.fds[fds:])
					c.fds = c.fds[:len(c.fds)-fds]
				}
			}
			c.mu.Unlock()
			continue
		}
		c.mu.Unlock()
		off := 0
		sig := obj.Interface().Events[opcode].Args
		args := make([]reflect.Value, len(sig))
		for i, arg := range sig {
			var num uint32
			if arg.Type != wlproto.ArgTypeFd {
				num = byteOrder.Uint32(d[off:])
				off += 4
			}
			switch arg.Type {
			case wlproto.ArgTypeInt:
				args[i] = reflect.ValueOf(int32(num))
			case wlproto.ArgTypeUint:
				args[i] = reflect.ValueOf(uint32(num))
			case wlproto.ArgTypeFixed:
				args[i] = reflect.ValueOf(Fixed(num))
			case wlproto.ArgTypeString:
				s := string(d[off : off+int(num)-1])
				args[i] = reflect.ValueOf(s)
				off += int(num)
				off = (off + 3) & ^3
			case wlproto.ArgTypeObject:
				c.mu.Lock()
				args[i] = reflect.ValueOf(c.objects[ObjectID(num)])
				c.mu.Unlock()
			case wlproto.ArgTypeArray:
				// XXX copy out the data, probably
				b := d[off : off+int(num)]
				args[i] = reflect.ValueOf(b)
				off += int(num)
				off = (off + 3) &^ 3
			case wlproto.ArgTypeFd:
				fd := c.fds[0]
				copy(c.fds, c.fds[1:])
				c.fds = c.fds[:len(c.fds)-1]
				args[i] = reflect.ValueOf(uintptr(fd))
			case wlproto.ArgTypeNewID:
				// new_id
				v := reflect.New(arg.Aux.Elem()).Interface().(Object)
				c.NewProxy(ObjectID(num), v, obj.Queue())
				c.mu.Lock()
				c.objects[ObjectID(num)] = v
				c.mu.Unlock()
			default:
				panic("unreachable")
			}
		}

		if sender == 1 && opcode == 1 {
			// Special case for the delete_id event on wl_display.
			// Primarily to clean up zombies, but this event may also
			// fire without us having called a server-side destructor.
			// For example, wl_callback gets destroyed by the server
			// once it has fired.
			c.mu.Lock()
			id := ObjectID(args[0].Uint())
			delete(c.objects, id)
			delete(c.zombies, id)
			c.mu.Unlock()
		}
		obj.GetProxy().queue.push(event{obj, int(opcode), args})
	}
}
